{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#exploring-python","title":"Exploring Python","text":"<p>Python runs the world's infrastructure. YouTube, Instagram, Spotify, Netflix, NASA\u2014all built on Python. Self-driving cars, scientific research, web backends, data analysis, machine learning\u2014Python powers it all.</p> <p>Why? Because Python combines simplicity with capability. It's a language that beginners can learn in weeks but experts use to build billion-user systems. That rare combination makes it indispensable.</p> <p>This site teaches Python from fundamentals through advanced topics\u2014not just syntax, but understanding. Each article builds conceptual foundations with clear explanations, annotated code examples, and practice problems. Whether you're starting from zero or reviewing core concepts, you'll find depth and clarity here.</p>"},{"location":"#what-makes-python-special","title":"What Makes Python Special?","text":"<p>Python's design philosophy centers on readability and practicality. Code reads like English. Complex operations have simple syntax. The standard library handles common tasks out of the box. You focus on solving problems, not fighting the language.</p> <p>Consider reading a CSV file and processing its data:</p> <p>In C: 50+ lines of pointer arithmetic, buffer management, and manual parsing.</p> <p>In Python:</p> <pre><code>import csv\nwith open('data.csv') as file:\n    for row in csv.reader(file):\n        process(row)\n</code></pre> <p>That's the Python advantage. Concise without being cryptic. Powerful without being complex.</p>"},{"location":"#learning-path","title":"Learning Path","text":""},{"location":"#level-1-foundations-start-here","title":"Level 1: Foundations (Start Here)","text":"<p>Master Python's core building blocks:</p> <p>Data Types</p> <ul> <li>Strings - Text processing, f-strings, methods</li> <li>Integers - Whole numbers, arithmetic, number systems</li> <li>Floating Point Numbers - Decimals, precision, scientific notation</li> <li>Booleans - Truth values, logical operators, truthiness</li> </ul> <p>Control Structures</p> <ul> <li>If Statements - Conditional logic and branching</li> <li>For Loops - Iteration over sequences</li> <li>While Loops - Condition-based loops</li> <li>Controlling Loops - <code>break</code>, <code>continue</code>, <code>else</code></li> <li>Functions - Defining reusable code blocks</li> <li>Comprehensions - Concise list/dict/set creation</li> </ul> <p>Data Structures</p> <ul> <li>Lists - Ordered, mutable collections</li> <li>Tuples - Immutable sequences</li> <li>Dictionaries - Key-value mappings</li> <li>Sets - Unique, unordered collections</li> <li>Membership Testing - Using <code>in</code> and <code>not in</code></li> <li>Slicing Sequences - Extracting portions</li> </ul>"},{"location":"#level-2-intermediate-concepts-coming-soon","title":"Level 2: Intermediate Concepts (Coming Soon)","text":"<ul> <li>Iterators and Generators - Memory-efficient iteration</li> <li>File I/O - Reading and writing files</li> <li>Exception Handling - Managing errors gracefully</li> <li>Modules and Packages - Organizing code</li> <li>Object-Oriented Programming - Classes and objects</li> </ul>"},{"location":"#level-3-advanced-topics-planned","title":"Level 3: Advanced Topics (Planned)","text":"<ul> <li>Decorators - Modifying function behavior</li> <li>Context Managers - Resource management with <code>with</code></li> <li>Metaclasses - Customizing class creation</li> <li>Async/Await - Concurrent programming</li> <li>Type Hints - Static type checking</li> </ul>"},{"location":"#content-philosophy","title":"Content Philosophy","text":"<p>Every article on this site follows these principles:</p> <ol> <li>Start with why - Real-world motivation before syntax</li> <li>Build progressively - Simple examples first, complexity layered</li> <li>Annotate code - Every non-obvious line explained</li> <li>Practice deliberately - Problems that test understanding, not memorization</li> <li>Link to official docs - Point you toward authoritative resources</li> </ol> <p>Python is a practical language. You learn by building. These articles give you the foundation to build confidently.</p>"},{"location":"#why-this-site-exists","title":"Why This Site Exists","text":"<p>Countless Python tutorials exist. Most teach syntax. Few teach understanding.</p> <p>This site focuses on conceptual depth: not just what Python does, but why it works that way. Not just memorizing methods, but internalizing patterns. Not just copy-paste examples, but principles you can apply.</p> <p>Python is a tool for computational problem-solving. To use it effectively, you need both the language mechanics and the computational thinking mindset that underlies all of computer science.</p> <p>The goal: transform you from someone who follows tutorials into someone who writes original solutions.</p>"},{"location":"#recent-updates","title":"Recent Updates","text":"<p>December 2025</p> <ul> <li>Refreshed Strings, Lists, and For Loops with enhanced examples and practice problems</li> <li>Added comprehensive code annotations throughout</li> <li>Standardized article structure across all topics</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>New to Python? Start with Strings, then work through the Data Types section sequentially. Each article builds on previous concepts.</p> <p>Reviewing fundamentals? Jump to any topic\u2014articles are self-contained with cross-links to related concepts.</p> <p>Experienced developer learning Python? Focus on Comprehensions and Dictionaries\u2014Python's approach differs from other languages.</p> <p>Python transformed programming from an expert-only activity to something accessible to millions. It didn't sacrifice power for simplicity\u2014it achieved both. That's why it's worth learning deeply.</p> <p>Welcome to Exploring Python. Let's build something.</p>"},{"location":"basics/control_structures/comprehensions/","title":"Comprehensions","text":"<p>Python comprehensions are elegant, concise, and widely used constructs that allow you to create new data structures by transforming and filtering existing iterables. \u2728 They're like magic one-liners \u2014 the espresso shot of Python. One sip (line) and you're awake (productive).</p> <p>They provide a more readable and often more performant alternative to traditional loops. Comprehensions can be used to create <code>lists</code>, <code>dictionaries</code>, and <code>sets</code>.</p>"},{"location":"basics/control_structures/comprehensions/#basic-comprehension-syntax","title":"Basic Comprehension Syntax","text":"<p>The most basic forms of comprehensions are:</p> Comprehension Syntax<pre><code># List comprehension\nnew_list = [expression for item in iterable]\n\n# Set comprehension\nnew_set = {expression for item in iterable}\n\n# Dictionary comprehension\nnew_dict = {key_expression: value_expression for item in iterable}\n</code></pre> <p>Here's a simple example of each:</p> Basic Comprehensions<pre><code>new_list = [x for x in range(10)]\nnew_set = {x for x in range(10)}\nnew_dict = {k: v for k, v in enumerate(range(10))}\n\nprint(f\"New List: {new_list}\")\nprint(f\"New Set: {new_set}\")\nprint(f\"New Dict: {new_dict}\")\n</code></pre> <p>Output: <pre><code>New List: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nNew Set: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\nNew Dict: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#comprehensions-vs-for-loops","title":"Comprehensions vs For Loops","text":"<p>Comprehensions are essentially a condensed form of <code>for</code> loops with automatic collection building. Both snippets below produce identical results:</p> Comprehensions vs For Loops<pre><code>for_loop_result = []\nfor x in range(5):\n    for_loop_result.append(x**2)\n\ncomprehension_result = [x**2 for x in range(5)]\n\nprint(f\"For Loop Result: {for_loop_result}\")\nprint(f\"Comprehension Result: {comprehension_result}\")\n</code></pre> <p>Output: <pre><code>For Loop Result: [0, 1, 4, 9, 16]\nComprehension Result: [0, 1, 4, 9, 16]\n</code></pre></p> <p>The comprehension is not only more concise (one line vs three), but many Python developers find it more readable and \"Pythonic.\" \ud83d\udc0d The expression <code>[x**2 for x in range(5)]</code> reads naturally as \"create a list of x-squared for each x in the range 0 to 4.\"</p>"},{"location":"basics/control_structures/comprehensions/#two-types-of-conditional-logic","title":"Two Types of Conditional Logic","text":"<p>Comprehensions support two distinct types of conditional logic, which serve different purposes and have different syntax positions:</p>"},{"location":"basics/control_structures/comprehensions/#1-filtering-with-if","title":"1. Filtering with <code>if</code>","text":"<p>Use filtering to determine which items to include in the result. The <code>if</code> condition comes after the <code>for</code> clause:</p> Filtering Comprehensions<pre><code># Syntax: [expression for item in iterable if condition]\neven_squares = [x**2 for x in range(10) if x % 2 == 0]\nprint(f\"Even squares: {even_squares}\")\n</code></pre> <p>Output: <pre><code>Even squares: [0, 4, 16, 36, 64]\n</code></pre></p> <p>This reads as \"create x-squared for each x in range 10, but only if x is even.\"</p>"},{"location":"basics/control_structures/comprehensions/#2-conditional-expressions-with-if-else","title":"2. Conditional Expressions with <code>if-else</code>","text":"<p>Use conditional expressions to determine what value each item should have. The <code>if-else</code> expression comes before the <code>for</code> clause:</p> Conditionals Comprehensions<pre><code># Syntax: [value_if_true if condition else value_if_false for item in iterable]\ngrades = [85, 92, 78, 65, 98, 72]\nresults = [\"Pass\" if grade &gt;= 70 else \"Fail\" for grade in grades]\nprint(f\"Results: {results}\")\n</code></pre> <p>Output: <pre><code>Results: ['Pass', 'Pass', 'Pass', 'Fail', 'Pass', 'Pass']\n</code></pre></p> <p>This reads as \"for each grade, assign 'Pass' if grade &gt;= 70, otherwise assign 'Fail'.\"</p>"},{"location":"basics/control_structures/comprehensions/#combining-both-patterns","title":"Combining Both Patterns","text":"<p>You can use both filtering and conditional expressions in the same comprehension:</p> Combining Filtering and Conditionals in Comprehensions<pre><code>categorized_evens = [\n    \"small\" if x &lt;= 5 else \"large\"\n    for x in range(15)\n    if x % 2 == 0\n]\nprint(f\"Categorized evens: {categorized_evens}\")\n</code></pre> <p>Output: <pre><code>Categorized evens: ['small', 'small', 'small', 'large', 'large', 'large', 'large']\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions are the most common type and create new lists by transforming existing iterables:</p> List Comprehensions<pre><code>words = ['apple', 'banana', 'cherry']\nuppercase_words = [word.upper() for word in words]\nprint(f\"Uppercase: {uppercase_words}\")\n\nstudents = [\n    {'name': 'Alice', 'grade': 85},\n    {'name': 'Bob', 'grade': 92},\n    {'name': 'Charlie', 'grade': 78}\n]\nnames = [student['name'] for student in students if student['grade'] &gt;= 80]\nprint(f\"High-performing students: {names}\")\n</code></pre> <p>Output: <pre><code>Uppercase: ['APPLE', 'BANANA', 'CHERRY']\nHigh-performing students: ['Alice', 'Bob']\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#set-comprehensions","title":"Set Comprehensions","text":"<p>Set comprehensions work identically to list comprehensions but use curly braces <code>{}</code> and automatically eliminate duplicates:</p> Set Comprehensions<pre><code>emails = ['user1@gmail.com', 'user2@yahoo.com', 'user3@gmail.com',\n          'user4@outlook.com', 'user5@gmail.com', 'user6@yahoo.com']\n\nunique_domains = {email.split('@')[1] for email in emails}\nprint(f\"Unique domains: {unique_domains}\")\n</code></pre> <p>Output: <pre><code>Unique domains: {'gmail.com', 'yahoo.com', 'outlook.com'}\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#dictionary-comprehensions","title":"Dictionary Comprehensions","text":"<p>Dictionary comprehensions create key-value pairs and require both a key and value expression:</p> Dictionary Comprehensions<pre><code>words = ['apple', 'banana', 'cherry', 'date', 'elderberry']\nword_lengths = {word: len(word) for word in words}\nprint(f\"Word lengths: {word_lengths}\")\n\nword_categories = {\n    word: 'short' if len(word) &lt;= 5 else 'long' # (1)\n    for word in words\n    if word.startswith(('a', 'e'))\n}\nprint(f\"Vowel words categorized: {word_categories}\")\n\ncelsius_temps = {'morning': 20, 'noon': 25, 'evening': 18}\nfahrenheit_temps = {\n    time: (temp * 9/5) + 32\n    for time, temp in celsius_temps.items()\n}\nprint(f\"Fahrenheit temps: {fahrenheit_temps}\")\n</code></pre> <ol> <li>For readability, it is common practice to break dictionary comprehensions into multiple lines.</li> </ol> <p>Output: <pre><code>Word lengths: {'apple': 5, 'banana': 6, 'cherry': 6, 'date': 4, 'elderberry': 10}\nVowel words categorized: {'apple': 'short', 'elderberry': 'long'}\nFahrenheit temps: {'morning': 68.0, 'noon': 77.0, 'evening': 64.4}\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#nested-comprehensions","title":"Nested Comprehensions","text":"<p>Comprehensions can be nested to handle more complex data structures:</p> Nested Comprehensions<pre><code># Flatten a 2D matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\nprint(f\"Flattened matrix: {flattened}\")\n\n# Create a multiplication table\nmultiplication_table = {\n    f\"{i}x{j}\": i * j\n    for i in range(1, 4)\n    for j in range(1, 4)\n}\nprint(f\"Multiplication table: {multiplication_table}\")\n</code></pre> <p>Output: <pre><code>Flattened matrix: [1, 2, 3, 4, 5, 6, 7, 8, 9]\nMultiplication table: {'1x1': 1, '1x2': 2, '1x3': 3, '2x1': 2, '2x2': 4, '2x3': 6, '3x1': 3, '3x2': 6, '3x3': 9}\n</code></pre></p>"},{"location":"basics/control_structures/comprehensions/#best-practices-common-patterns","title":"Best Practices &amp; Common Patterns","text":"<p>Use comprehensions:</p> <ul> <li>Creating a new collection from an existing one</li> <li>The logic is simple and readable</li> <li>You need filtering and/or transformation in one step</li> <li>Performance matters (comprehensions are often faster than equivalent loops)</li> </ul> <p>Avoid comprehensions:</p> <ul> <li>The logic becomes too complex or deeply nested</li> <li>Side effects are needed (printing, file I/O, etc.)</li> <li>The comprehension becomes difficult to read</li> </ul> Common Patterns for Comprehensions<pre><code># Pattern 1: Data extraction and transformation\ndata = [\n    {'name': 'Alice', 'age': 25, 'city': 'NYC'},\n    {'name': 'Bob', 'age': 30, 'city': 'LA'},\n    {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n]\n\n# Extract names of people over 25\nmature_names = [person['name'] for person in data if person['age'] &gt; 25]\n\n# Pattern 2: String processing\ntext = \"Hello World Python Programming\"\nword_lengths = {word.lower(): len(word) for word in text.split()}\n\n# Pattern 3: Mathematical operations\ncoordinates = [(1, 2), (3, 4), (5, 6)]\ndistances = [x**2 + y**2 for x, y in coordinates]\n\n# Pattern 4: Conditional categorization\nnumbers = range(1, 21)\nnumber_types = {\n    num: 'even' if num % 2 == 0 else 'odd'\n    for num in numbers\n    if num % 5 != 0  # Exclude multiples of 5\n}\n\nprint(f\"Mature names: {mature_names}\")\nprint(f\"Word lengths: {word_lengths}\")\nprint(f\"Distances: {distances}\")\nprint(f\"Number types: {number_types}\")\n</code></pre>"},{"location":"basics/control_structures/comprehensions/#comprehension-flow-diagram","title":"Comprehension Flow Diagram","text":"<pre><code>flowchart TD\n    A[Start with an iterable] --&gt; B[Iterate through each item]\n    B --&gt; C{Filter condition present?}\n    C --&gt;|No| E[Apply expression to item]\n    C --&gt;|Yes| D{Item passes filter?}\n    D --&gt;|Yes| E\n    D --&gt;|No| F[Skip item]\n    E --&gt; G{Conditional expression&lt;br/&gt;present?}\n    G --&gt;|Yes| H[Apply if-else logic&lt;br/&gt;to determine value]\n    G --&gt;|No| I[Use expression result as value]\n    H --&gt; J[Add to result collection]\n    I --&gt; J\n    F --&gt; K{More items?}\n    J --&gt; K\n    K --&gt;|Yes| B\n    K --&gt;|No| L[Return final collection]</code></pre>"},{"location":"basics/control_structures/comprehensions/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember List comprehension <code>[expr for item in iterable]</code> Set comprehension <code>{expr for item in iterable}</code> \u2014 auto-deduplicates Dict comprehension <code>{key: value for item in iterable}</code> Filtering <code>... if condition</code> after the <code>for</code> clause Conditional value <code>value_if_true if cond else value_if_false</code> before <code>for</code> Nested loops <code>for x in xs for y in ys</code> \u2014 outer loop first When to avoid Complex logic, side effects, or hard-to-read expressions"},{"location":"basics/control_structures/comprehensions/#video-summary","title":"Video Summary","text":""},{"location":"basics/control_structures/controlling_loops/","title":"Controlling Loops","text":"<p>Loops in Python are great for repetition \u2014 but sometimes, you need to take control. Maybe you want to skip ahead, stop early, or do something special at the end. That\u2019s where the loop control keywords <code>continue</code>, <code>break</code>, and <code>else</code> come in.</p> <p>This guide explores how these keywords work and shows you how to use them effectively \u2014 with a few playful examples along the way.</p>"},{"location":"basics/control_structures/controlling_loops/#continuing-a-loop","title":"Continuing a Loop","text":"<p>Sometimes, we want to skip over part of a loop's work for a particular iteration without stopping the whole thing.  That\u2019s where <code>continue</code> comes in \u2014 it tells the loop: \u201cSkip the rest of this turn, move on to the next!\u201d</p> Using Continue to Skip Ahead<pre><code>colours = [\"red\", \"green\", \"blue\", \"orange\"]\n\nfor colour in colours:\n    if colour == \"orange\":\n        print(\"Ugh, orange again? Let's pretend we didn't see that.\")\n        continue\n    print(f\"Ooooh, I totally dig the colour {colour}!\")\n</code></pre> <p>Would result in:</p> <pre><code>Ooooh, I totally dig the colour red!\nOoooh, I totally dig the colour green!\nOoooh, I totally dig the colour blue!\nUgh, orange again? Let's pretend we didn't see that.\n</code></pre> Tip <p>Often, continue can be replaced by simply using an if statement to wrap the block of code. For example: if colour != \"orange\": print(...) would achieve the same result. That said, continue can be helpful for readability \u2014 just use it mindfully.</p>"},{"location":"basics/control_structures/controlling_loops/#breaking-a-loop","title":"Breaking a Loop","text":"<p>Sometimes, we want to stop a loop entirely when something important happens. This is known as abnormal termination, and the <code>break</code> statement is your go-to tool.</p> <p>In the example below, we simulate a bank account that refuses to go into the red:</p> Using Break to Escape a Loop<pre><code>balance = 100\nwithdrawals = [10, 23, 12, 16, 43, 19, 4, 5]\n\nfor withdrawal in withdrawals:\n    print(f\"\ud83d\udce4 Request to withdraw ${withdrawal}...\")\n\n    if (balance - withdrawal) &lt; 0:\n        print(\"\ud83d\udea8 Uh-oh! You're broke. No more money magic today.\")\n        break\n\n    balance -= withdrawal\n    print(f\"\u2705 Success! You withdrew ${withdrawal}. Remaining balance: ${balance}\")\n</code></pre> <p>Would result in:</p> <pre><code>\ud83d\udce4 Request to withdraw $10...\n\u2705 Success! You withdrew $10. Remaining balance: $90\n\ud83d\udce4 Request to withdraw $23...\n\u2705 Success! You withdrew $23. Remaining balance: $67\n\ud83d\udce4 Request to withdraw $12...\n\u2705 Success! You withdrew $12. Remaining balance: $55\n\ud83d\udce4 Request to withdraw $16...\n\u2705 Success! You withdrew $16. Remaining balance: $39\n\ud83d\udce4 Request to withdraw $43...\n\ud83d\udea8 Uh-oh! You're broke. No more money magic today.\n</code></pre> <p>Like the <code>continue</code> statement, <code>break</code> should also be used with caution.  In the example above the same functionality could have been achieved with a <code>while</code> loop.  Use with discretion!</p>"},{"location":"basics/control_structures/controlling_loops/#using-else-with-for-loops","title":"Using Else with For Loops","text":"<p>One of Python\u2019s lesser-known features is the ability to attach an <code>else</code> block to a loop. This block will run only if the loop completes naturally \u2014 that is, not interrupted by a <code>break</code>.</p> <p>Here\u2019s a playful example that builds on our earlier scenario:</p> Adding an Else to a For Loop<pre><code>balance = 200\nwithdrawals = [10, 23, 12, 16, 43, 19, 4, 5]\n\nprint(\"\ud83d\udcb8 Time for a little shopping adventure!\")\n\nfor withdrawal in withdrawals:\n    print(f\"\ud83d\uded2 You spot something for ${withdrawal}...\")\n\n    if (balance - withdrawal) &lt; 0:\n        print(\"\ud83d\ude31 Your wallet gasps in horror \u2014 not enough cash!\")\n        print(\"\ud83d\udc80 The spree ends here, friend.\")\n        break\n\n    balance -= withdrawal\n    print(f\"\ud83c\udf89 Purchase successful! You\u2019ve got ${balance} left in your treasure chest.\")\nelse:\n    print(\"\ud83c\udf8a You made it through your spree without going broke!\")\n</code></pre> <p>Would result in:</p> <pre><code>\ud83d\udcb8 Time for a little shopping adventure!\n\ud83d\uded2 You spot something for $10...\n\ud83c\udf89 Purchase successful! You\u2019ve got $190 left in your treasure chest.\n\ud83d\uded2 You spot something for $23...\n\ud83c\udf89 Purchase successful! You\u2019ve got $167 left in your treasure chest.\n\ud83d\uded2 You spot something for $12...\n\ud83c\udf89 Purchase successful! You\u2019ve got $155 left in your treasure chest.\n\ud83d\uded2 You spot something for $16...\n\ud83c\udf89 Purchase successful! You\u2019ve got $139 left in your treasure chest.\n\ud83d\uded2 You spot something for $43...\n\ud83c\udf89 Purchase successful! You\u2019ve got $96 left in your treasure chest.\n\ud83d\uded2 You spot something for $19...\n\ud83c\udf89 Purchase successful! You\u2019ve got $77 left in your treasure chest.\n\ud83d\uded2 You spot something for $4...\n\ud83c\udf89 Purchase successful! You\u2019ve got $73 left in your treasure chest.\n\ud83d\uded2 You spot something for $5...\n\ud83c\udf89 Purchase successful! You\u2019ve got $68 left in your treasure chest.\n\ud83c\udf8a You made it through your spree without going broke!\n</code></pre> <p>Using else in loops isn't especially common, but when used well, it can express logic cleanly \u2014 particularly in search loops, or when you want to take special action only if no early exit occurred.</p>"},{"location":"basics/control_structures/controlling_loops/#a-classic-use-case-searching","title":"A Classic Use Case: Searching","text":"<p>The <code>else</code> clause shines when searching for something \u2014 if you find it, you <code>break</code>; if you don't, the <code>else</code> runs:</p> Search Loop with Else<pre><code>users = [\"alice\", \"bob\", \"charlie\", \"diana\"]\nlooking_for = \"eve\"\n\nfor user in users:\n    if user == looking_for:\n        print(f\"Found {user}! \u2705\")\n        break\nelse:\n    print(f\"User '{looking_for}' not found. \ud83d\udd0d\")\n</code></pre> <p>Returns:</p> <pre><code>User 'eve' not found. \ud83d\udd0d\n</code></pre>"},{"location":"basics/control_structures/controlling_loops/#controlling-nested-loops","title":"Controlling Nested Loops","text":"<p>When you have loops inside loops, <code>break</code> and <code>continue</code> only affect the innermost loop. This can trip people up!</p> Break Only Exits Inner Loop<pre><code>for i in range(3):\n    print(f\"Outer loop: {i}\")\n    for j in range(3):\n        if j == 1:\n            break  # Only breaks the inner loop!\n        print(f\"  Inner loop: {j}\")\n</code></pre> <p>Returns:</p> <pre><code>Outer loop: 0\n  Inner loop: 0\nOuter loop: 1\n  Inner loop: 0\nOuter loop: 2\n  Inner loop: 0\n</code></pre> <p>Notice the outer loop keeps running \u2014 <code>break</code> only escaped the inner loop.</p>"},{"location":"basics/control_structures/controlling_loops/#breaking-out-of-multiple-loops","title":"Breaking Out of Multiple Loops","text":"<p>If you need to break out of nested loops entirely, you have a few options:</p> <p>Option 1: Use a flag</p> Flag Variable<pre><code>found = False\nfor i in range(5):\n    for j in range(5):\n        if i * j == 6:\n            print(f\"Found it at ({i}, {j})!\")\n            found = True\n            break\n    if found:\n        break\n</code></pre> <p>Option 2: Move loops into a function and use <code>return</code></p> Extract to Function<pre><code>def find_pair():\n    for i in range(5):\n        for j in range(5):\n            if i * j == 6:\n                return (i, j)  # Exits the entire function\n    return None\n\nresult = find_pair()\nif result:\n    print(f\"Found it at {result}!\")\n</code></pre> <p>Option 3: Use an exception (rarely needed)</p> Exception-Based Exit<pre><code>class FoundIt(Exception):\n    pass\n\ntry:\n    for i in range(5):\n        for j in range(5):\n            if i * j == 6:\n                raise FoundIt()\nexcept FoundIt:\n    print(f\"Found it at ({i}, {j})!\")\n</code></pre> <p>Which Approach?</p> <p>The function approach (Option 2) is usually the cleanest. If you find yourself needing to break out of nested loops, it's often a sign that the logic should be extracted into a function anyway. Clean code is like good coffee \u2014 worth the extra effort. \u2615</p>"},{"location":"basics/control_structures/controlling_loops/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember continue Skip to the next iteration break Exit the loop entirely else clause Runs only if no <code>break</code> occurred Nested loops <code>break</code>/<code>continue</code> only affect the innermost loop Breaking out Use a flag, extract to function, or (rarely) raise an exception Best practice Extract nested loops to functions for cleaner <code>return</code>-based exits"},{"location":"basics/control_structures/controlling_loops/#video-summary","title":"Video Summary","text":""},{"location":"basics/control_structures/for_loops/","title":"For Loops","text":"<p>Process a list of email addresses. Analyze each line in a log file. Generate multiplication tables. Calculate statistics across datasets. Render pixels in an image.</p> <p>Every one of these tasks requires doing the same operation repeatedly\u2014just with different data each time. That's what for loops enable: systematic iteration over collections.</p> <p>Computers excel at repetition without fatigue or error. For loops are how you harness that power in Python.</p>"},{"location":"basics/control_structures/for_loops/#what-is-a-for-loop","title":"What is a For Loop?","text":"<p>A for loop executes a block of code once for each item in a sequence (list, string, range, etc.):</p> Basic For Loop Structure<pre><code>for item in sequence:  # (1)!\n    # Code to execute for each item\n    print(item)\n</code></pre> <ol> <li>The loop variable (<code>item</code>) takes on each value from the sequence in order</li> </ol> <p>Here's a concrete example:</p> Iterating Over a List<pre><code>languages = [\"Python\", \"JavaScript\", \"Go\"]\nfor language in languages:  # (1)!\n    print(f\"I'm learning {language}\")\n</code></pre> <ol> <li><code>language</code> becomes \"Python\", then \"JavaScript\", then \"Go\" on successive iterations</li> </ol> <p>Output: <pre><code>I'm learning Python\nI'm learning JavaScript\nI'm learning Go\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#why-for-loops-matter","title":"Why For Loops Matter","text":"<p>For loops solve a fundamental problem: applying operations across collections without writing repetitive code. This is computational thinking in action\u2014decomposing a large task (process 1000 items) into a simple, repeatable pattern (process one item, repeat).</p> <p>Without loops, processing three items requires three nearly-identical code blocks:</p> Without Loops (Don't Do This)<pre><code>print(f\"Processing {items[0]}\")\nprint(f\"Processing {items[1]}\")\nprint(f\"Processing {items[2]}\")\n# What if you have 100 items? 10,000?\n</code></pre> <p>With loops, one block handles any number of items:</p> With Loops (Better)<pre><code>for item in items:  # (1)!\n    print(f\"Processing {item}\")\n</code></pre> <ol> <li>Works for 3 items, 300 items, or 3 million items</li> </ol> <p>Loops make your code:</p> <ul> <li>Scalable: Works with any collection size</li> <li>Maintainable: Change the logic once, not N times</li> <li>Readable: Expresses intent clearly</li> </ul>"},{"location":"basics/control_structures/for_loops/#looping-over-different-sequences","title":"Looping Over Different Sequences","text":""},{"location":"basics/control_structures/for_loops/#lists","title":"Lists","text":"<p>The most common use case\u2014iterate over list elements:</p> Processing List Items<pre><code>scores = [85, 92, 78, 90, 88]\ntotal = 0\nfor score in scores:  # (1)!\n    total += score\naverage = total / len(scores)\nprint(f\"Average score: {average}\")\n</code></pre> <ol> <li>Each iteration, <code>score</code> takes on the next value from the list (85, then 92, then 78, etc.)</li> </ol>"},{"location":"basics/control_structures/for_loops/#strings","title":"Strings","text":"<p>Strings are sequences of characters, so you can loop over them:</p> Iterating Over Characters<pre><code>word = \"Python\"\nfor letter in word:  # (1)!\n    print(letter)\n</code></pre> <ol> <li>Each character becomes the loop variable in turn</li> </ol> <p>Output: <pre><code>P\ny\nt\nh\no\nn\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#dictionaries","title":"Dictionaries","text":"<p>Loop over dictionary keys, values, or both:</p> Dictionary Iteration<pre><code>user = {\"name\": \"Alice\", \"age\": 30, \"city\": \"Boston\"}\n\n# Loop over keys\nfor key in user.keys():  # (1)!\n    print(key)\n\n# Loop over values\nfor value in user.values():  # (2)!\n    print(value)\n\n# Loop over key-value pairs\nfor key, value in user.items():  # (3)!\n    print(f\"{key}: {value}\")\n</code></pre> <ol> <li><code>.keys()</code> returns the dictionary keys\u2014actually the default behavior</li> <li><code>.values()</code> returns just the values</li> <li><code>.items()</code> returns tuples of <code>(key, value)</code> pairs\u2014note we unpack into two variables</li> </ol> <p>Output of <code>.items()</code> loop: <pre><code>name: Alice\nage: 30\ncity: Boston\n</code></pre></p> Dictionary Unpacking <p><code>for key, value in user.items()</code> uses tuple unpacking. Each iteration, <code>.items()</code> returns a tuple like <code>(\"name\", \"Alice\")</code>, which Python automatically unpacks into the two variables.</p>"},{"location":"basics/control_structures/for_loops/#the-range-function","title":"The <code>range()</code> Function","text":"<p>Need to repeat an action exactly N times? Generate a sequence of IDs? Count from 1 to 100? The <code>range()</code> function generates number sequences for counted loops:</p> Basic Range Usage<pre><code>for i in range(5):  # (1)!\n    print(i)\n</code></pre> <ol> <li><code>range(5)</code> generates numbers from 0 to 4 (not including 5)</li> </ol> <p>Output: <pre><code>0\n1\n2\n3\n4\n</code></pre></p> <p>Off-By-One Trap</p> <p><code>range()</code> stops before the end value. <code>range(10)</code> generates 0-9, not 1-10. This is Python's most common off-by-one error.</p>"},{"location":"basics/control_structures/for_loops/#range-with-start-and-stop","title":"Range with Start and Stop","text":"<p>Skip header rows when processing files. Process items 10-20 from a dataset. Generate IDs starting from a specific number:</p> Range with Start and Stop<pre><code>for i in range(3, 8):  # (1)!\n    print(i)\n</code></pre> <ol> <li><code>range(start, stop)</code> goes from start (inclusive) to stop (exclusive)</li> </ol> <p>Output: <pre><code>3\n4\n5\n6\n7\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#range-with-step","title":"Range with Step","text":"<p>Process every other row in a spreadsheet. Sample data (take every 100th record). Generate sequences like even numbers or multiples of 5:</p> Range with Step<pre><code>for i in range(0, 10, 2):  # (1)!\n    print(i)\n</code></pre> <ol> <li><code>range(start, stop, step)</code> increments by step each time</li> </ol> <p>Output: <pre><code>0\n2\n4\n6\n8\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#counting-backwards","title":"Counting Backwards","text":"<p>Countdown timers. Processing undo stack (most recent first). Reverse iteration when building output in reverse order:</p> Counting Backwards<pre><code>for i in range(10, 0, -1):  # (1)!\n    print(i)\nprint(\"Liftoff!\")\n</code></pre> <ol> <li>Start at 10, stop before 0, decrement by 1</li> </ol> <p>Output: <pre><code>10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nLiftoff!\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#looping-with-indices-enumerate","title":"Looping with Indices: <code>enumerate()</code>","text":"<p>Displaying numbered lists (\"1. First item, 2. Second item...\"). Tracking position while processing. Comparing items to their neighbors by index. When you need both the value and its position, <code>enumerate()</code> provides both:</p> Enumerate for Index and Item<pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nfor index, fruit in enumerate(fruits):  # (1)!\n    print(f\"{index}: {fruit}\")\n</code></pre> <ol> <li><code>enumerate()</code> yields tuples of <code>(index, item)</code> which we unpack</li> </ol> <p>Output: <pre><code>0: apple\n1: banana\n2: cherry\n</code></pre></p> <p>Start counting from 1 instead of 0:</p> Enumerate with Custom Start<pre><code>for index, fruit in enumerate(fruits, start=1):  # (1)!\n    print(f\"{index}. {fruit}\")\n</code></pre> <ol> <li><code>start=1</code> makes the index begin at 1 instead of 0</li> </ol> <p>Output: <pre><code>1. apple\n2. banana\n3. cherry\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#nested-loops","title":"Nested Loops","text":"<p>Multiplication tables. Processing 2D grids (chess boards, images, spreadsheets). Comparing every item with every other item. Nested loops handle multidimensional problems:</p> Nested Loops<pre><code>for i in range(1, 4):  # (1)!\n    for j in range(1, 4):  # (2)!\n        print(f\"{i} \u00d7 {j} = {i * j}\")\n    print()  # Blank line between groups\n</code></pre> <ol> <li>Outer loop runs 3 times</li> <li>For each outer iteration, inner loop runs 3 times (total: 3 \u00d7 3 = 9 iterations)</li> </ol> <p>Output: <pre><code>1 \u00d7 1 = 1\n1 \u00d7 2 = 2\n1 \u00d7 3 = 3\n\n2 \u00d7 1 = 2\n2 \u00d7 2 = 4\n2 \u00d7 3 = 6\n\n3 \u00d7 1 = 3\n3 \u00d7 2 = 6\n3 \u00d7 3 = 9\n</code></pre></p> <p>Performance Warning</p> <p>Nested loops multiply execution time. Two loops of 100 items each = 10,000 iterations. Three loops of 100 = 1,000,000 iterations. Be mindful with large datasets.</p>"},{"location":"basics/control_structures/for_loops/#looping-over-multiple-sequences-zip","title":"Looping Over Multiple Sequences: <code>zip()</code>","text":"<p>Combining first names with last names. Matching products with prices. Processing parallel lists of data. When you have related data in separate lists, <code>zip()</code> pairs them element-by-element:</p> Zipping Sequences<pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [30, 25, 35]\n\nfor name, age in zip(names, ages):  # (1)!\n    print(f\"{name} is {age} years old\")\n</code></pre> <ol> <li><code>zip()</code> pairs corresponding elements: (\"Alice\", 30), (\"Bob\", 25), (\"Charlie\", 35)</li> </ol> <p>Output: <pre><code>Alice is 30 years old\nBob is 25 years old\nCharlie is 35 years old\n</code></pre></p> <p>If sequences differ in length, <code>zip()</code> stops at the shortest:</p> Zip Stops at Shortest<pre><code>a = [1, 2, 3]\nb = ['a', 'b']\nfor num, letter in zip(a, b):  # (1)!\n    print(num, letter)\n</code></pre> <ol> <li>Only 2 pairs are created because <code>b</code> has only 2 elements</li> </ol> <p>Output: <pre><code>1 a\n2 b\n</code></pre></p>"},{"location":"basics/control_structures/for_loops/#practical-patterns","title":"Practical Patterns","text":""},{"location":"basics/control_structures/for_loops/#accumulating-values","title":"Accumulating Values","text":"<p>Calculate totals from transactions. Count how many items match a criterion. Find the maximum value. Track a running average:</p> Summing a List<pre><code>numbers = [10, 20, 30, 40]\ntotal = 0  # (1)!\nfor num in numbers:\n    total += num  # (2)!\nprint(total)\n</code></pre> <ol> <li>Initialize the accumulator variable to 0 before the loop starts</li> <li>Add each number to the accumulator on each iteration (final result: 100)</li> </ol>"},{"location":"basics/control_structures/for_loops/#building-new-lists","title":"Building New Lists","text":"<p>Apply tax to prices. Convert temperatures from Celsius to Fahrenheit. Extract specific fields from records. Generate derived data:</p> Transforming List Values<pre><code>prices = [10.99, 5.99, 23.50]\nprices_with_tax = []  # (1)!\nfor price in prices:\n    with_tax = price * 1.13  # (2)!\n    prices_with_tax.append(with_tax)\nprint(prices_with_tax)\n</code></pre> <ol> <li>Create an empty list to hold the results before the loop</li> <li>Calculate the new value (price plus 13% tax) and append it to the results list</li> </ol> List Comprehensions <p>Python has a more concise syntax for this pattern called list comprehensions. See the Comprehensions article for details.</p>"},{"location":"basics/control_structures/for_loops/#filtering-data","title":"Filtering Data","text":"<p>Remove invalid email addresses. Find all orders above $100. Separate active from inactive users. Extract matching search results:</p> Finding Specific Items<pre><code>numbers = [15, 8, 23, 4, 16, 42]\neven_numbers = []\nfor num in numbers:\n    if num % 2 == 0:  # (1)!\n        even_numbers.append(num)\nprint(even_numbers)  # [8, 4, 16, 42]\n</code></pre> <ol> <li>Only append items that meet the condition</li> </ol>"},{"location":"basics/control_structures/for_loops/#for-vs-while-loops","title":"For vs While Loops","text":"<p>Python has two types of loops:</p> <ul> <li>For loops: \"Do this for each item\" (iteration over known sequences)</li> <li>While loops: \"Do this until condition becomes false\" (iteration until something happens)</li> </ul> <p>Use for loops when you know what you're iterating over:</p> For Loop (Known Sequence)<pre><code>for i in range(10):  # (1)!\n    print(i)\n</code></pre> <ol> <li>We know we want exactly 10 iterations</li> </ol> <p>Use while loops when you don't know how many iterations you need:</p> While Loop (Unknown Count)<pre><code>user_input = \"\"\nwhile user_input != \"quit\":  # (1)!\n    user_input = input(\"Enter command (or 'quit'): \")\n</code></pre> <ol> <li>Loop until user types \"quit\"\u2014we don't know how many iterations that takes</li> </ol> <p>See While Loops for more on while loops.</p>"},{"location":"basics/control_structures/for_loops/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"basics/control_structures/for_loops/#modifying-a-list-while-iterating","title":"Modifying a List While Iterating","text":"<p>Don't modify a list you're currently iterating over:</p> Dangerous: Modifying During Iteration<pre><code>numbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    if num % 2 == 0:\n        numbers.remove(num)  # (1)!\n</code></pre> <ol> <li>\u26a0\ufe0f Don't do this! Modifying the list during iteration causes elements to be skipped\u2014a subtle and dangerous bug</li> </ol> <p>Solution: Iterate over a copy or build a new list:</p> Safe: Building New List<pre><code>numbers = [1, 2, 3, 4, 5]\nodd_numbers = []\nfor num in numbers:  # (1)!\n    if num % 2 != 0:\n        odd_numbers.append(num)\n</code></pre> <ol> <li>Iterate over original, build new list\u2014safe and clear</li> </ol>"},{"location":"basics/control_structures/for_loops/#range-off-by-one-error","title":"Range Off-By-One Error","text":"Range Excludes End Value<pre><code>for i in range(10):\n    print(i)  # (1)!\n</code></pre> <ol> <li>Prints 0-9, not 1-10! <code>range(10)</code> generates 0, 1, 2, ..., 9 (stops before 10)</li> </ol> <p>To iterate from 1 to 10:</p> Correct Range for 1-10<pre><code>for i in range(1, 11):  # (1)!\n    print(i)\n</code></pre> <ol> <li>Start at 1, stop before 11 (so last value is 10)</li> </ol>"},{"location":"basics/control_structures/for_loops/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Basic Iteration <p>Write a for loop that prints each character in the string <code>\"Python\"</code> on a separate line.</p> Answer <pre><code>word = \"Python\"\nfor letter in word:\n    print(letter)\n</code></pre> <p>Strings are sequences, so you can iterate over their characters.</p> Practice Problem 2: Range Usage <p>What does this code print?</p> <pre><code>for i in range(3, 10, 2):\n    print(i)\n</code></pre> Answer <pre><code>3\n5\n7\n9\n</code></pre> <p><code>range(3, 10, 2)</code> starts at 3, stops before 10, increments by 2 each time.</p> Practice Problem 3: Enumerate <p>How would you print each item in <code>fruits = [\"apple\", \"banana\", \"cherry\"]</code> with its position number starting from 1?</p> Answer <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nfor index, fruit in enumerate(fruits, start=1):\n    print(f\"{index}. {fruit}\")\n</code></pre> <p><code>enumerate(fruits, start=1)</code> yields <code>(1, \"apple\")</code>, <code>(2, \"banana\")</code>, <code>(3, \"cherry\")</code>.</p> Practice Problem 4: Accumulation <p>Write a loop that calculates the product of all numbers in <code>[2, 3, 4, 5]</code>.</p> Answer <pre><code>numbers = [2, 3, 4, 5]\nproduct = 1  # Start at 1 (not 0!) for multiplication\nfor num in numbers:\n    product *= num\nprint(product)  # 120 (2 \u00d7 3 \u00d7 4 \u00d7 5)\n</code></pre> <p>For multiplication, initialize the accumulator to 1, not 0.</p>"},{"location":"basics/control_structures/for_loops/#key-takeaways","title":"Key Takeaways","text":"Concept What It Means For loop Execute code once for each item in a sequence <code>range()</code> Generate sequences of numbers: <code>range(start, stop, step)</code> <code>enumerate()</code> Get both index and item: <code>for i, item in enumerate(seq)</code> <code>zip()</code> Pair elements from multiple sequences Loop variable Takes on each value from the sequence in turn Nested loops Loops inside loops\u2014useful for multidimensional data"},{"location":"basics/control_structures/for_loops/#further-reading","title":"Further Reading","text":"<ul> <li>Python For Loops Tutorial - Official Python documentation</li> <li>Itertools Module - Advanced iteration tools</li> <li>List Comprehensions - More concise syntax for common loop patterns</li> <li>While Loops - Loops based on conditions rather than sequences</li> </ul> <p>For loops are one of the first control structures you'll learn, and one you'll use daily. They transform repetitive manual work into systematic, scalable operations. Master iteration\u2014over lists, strings, ranges, and dictionaries\u2014and you can process any collection Python throws at you.</p> <p>Every complex program is built on simple loops. Learn to write them well.</p>"},{"location":"basics/control_structures/functions/","title":"Functions","text":"<p>Validate user email formats. Calculate shipping costs. Send welcome emails. Parse JSON responses. Format database queries. Hash passwords. Convert temperatures. Every one of these tasks gets repeated throughout your codebase\u2014sometimes hundreds of times.</p> <p>Functions let you write the logic once, name it, and reuse it everywhere. They're the fundamental building block of code organization, enabling you to break complex programs into manageable, testable, reusable pieces. Master functions, and you master abstraction\u2014one of the core principles of programming.</p>"},{"location":"basics/control_structures/functions/#what-is-a-function","title":"What is a Function?","text":"<p>A function is a named, reusable block of code that performs a specific task. You define it once with <code>def</code>, then call it as many times as needed:</p> Basic Function<pre><code>def add_numbers(a: int, b: int) -&gt; int:  # (1)!\n    return a + b  # (2)!\n\nresult = add_numbers(5, 3)  # (3)!\nprint(result)  # 8\n</code></pre> <ol> <li>Function definition: <code>def</code> keyword, name (<code>add_numbers</code>), parameters with type hints (<code>a: int, b: int</code>), return type annotation (<code>-&gt; int</code>), colon</li> <li>The <code>return</code> statement sends a value back to the caller\u2014this function returns the sum</li> <li>Function call: use the function name with parentheses and arguments\u2014the function executes and returns <code>8</code></li> </ol> <p>Function anatomy:</p> <ul> <li><code>def</code> keyword: Declares the start of a function definition</li> <li>Function name: Identifies the function (use descriptive names: <code>calculate_tax</code>, not <code>ct</code>)</li> <li>Parameters: Inputs the function accepts (can be zero or more)</li> <li>Type hints (optional): Document expected types\u2014<code>a: int</code> means <code>a</code> should be an integer, <code>-&gt; int</code> means it returns an integer</li> <li>Colon: Marks the end of the definition line</li> <li>Indented body: The code that runs when the function is called</li> <li><code>return</code> statement: Sends a value back to the caller (optional\u2014functions without <code>return</code> implicitly return <code>None</code>)</li> </ul>"},{"location":"basics/control_structures/functions/#why-functions-matter","title":"Why Functions Matter","text":"<p>Functions are how programmers manage complexity. They enable:</p> <ul> <li>Code reuse: Write once, use everywhere\u2014email validation, tax calculation, data formatting all become one-liners</li> <li>Maintainability: Fix a bug in one place, and every call gets the fix\u2014no hunting through thousands of lines for copy-pasted code</li> <li>Testability: Test a function in isolation with known inputs and expected outputs\u2014much easier than testing entire programs</li> <li>Abstraction: Hide complex logic behind simple names\u2014<code>send_email()</code> is clearer than 50 lines of SMTP protocol code</li> <li>Organization: Break 1000-line scripts into 20 well-named functions\u2014each does one thing well</li> <li>Collaboration: Teams can work on different functions simultaneously\u2014clear interfaces between components</li> </ul> <p>Without functions, every program would be a linear script. Functions transform code from a sequence of instructions into a collection of reusable tools.</p>"},{"location":"basics/control_structures/functions/#dry-dont-repeat-yourself","title":"DRY: Don't Repeat Yourself","text":"<p>Send the same welcome message to multiple users. Apply the same validation to multiple form fields. Calculate the same metric for different datasets. Repetition is code smell\u2014functions eliminate it:</p> Repetitive Code (Don't Do This)<pre><code>user1 = \"Carl\"\nuser2 = \"Jim\"\nuser3 = \"Fred\"\n\nprint(\"Greetings \" + user1 + \", welcome to this program.\")  # (1)!\nprint(\"Greetings \" + user2 + \", welcome to this program.\")\nprint(\"Greetings \" + user3 + \", welcome to this program.\")\n</code></pre> <ol> <li>Same string concatenation repeated three times\u2014error-prone and hard to change</li> </ol> DRY with Functions<pre><code>def greet(user: str) -&gt; str:  # (1)!\n    return f\"Greetings {user}, welcome to this program.\"\n\nusers = [\"Carl\", \"Jim\", \"Fred\"]  # (2)!\nfor user in users:\n    print(greet(user))\n</code></pre> <ol> <li>Define the logic once\u2014now changing the greeting message requires editing one line, not three (or hundreds)</li> <li>Combine with a for loop to process any number of users\u2014scales from 3 to 3000</li> </ol>"},{"location":"basics/control_structures/functions/#functions-with-loops","title":"Functions with Loops","text":"<p>Convert multiple temperatures. Process a batch of files. Validate a list of email addresses\u2014apply the same function to different inputs by combining functions with <code>for</code> loops:</p> Applying Functions to Multiple Inputs<pre><code>def celsius_to_kelvin(celsius: float) -&gt; float:  # (1)!\n    return celsius + 273.15\n\ntemperatures_c = [9.1, 8.8, -270.15]\nfor temp in temperatures_c:  # (2)!\n    kelvin = celsius_to_kelvin(temp)\n    print(f\"{temp}\u00b0C = {kelvin}K\")\n</code></pre> <ol> <li>Define the conversion logic once\u2014this function handles any single temperature</li> <li>Loop over the list and apply the function to each element\u2014output: \"9.1\u00b0C = 282.25K\", \"8.8\u00b0C = 281.95K\", \"-270.15\u00b0C = 3.0K\"</li> </ol> <p>This pattern\u2014define function, apply to collection\u2014is fundamental to data processing. You could process 3 temperatures or 3 million with the same code.</p>"},{"location":"basics/control_structures/functions/#default-parameter-values","title":"Default Parameter Values","text":"<p>Greeting messages with customizable text. API calls with optional parameters. Configuration functions with sensible defaults\u2014default values make parameters optional:</p> Default Parameters<pre><code>def greet(name: str, greeting: str = \"Hello\", punctuation: str = \"!\") -&gt; str:  # (1)!\n    return f\"{greeting}, {name}{punctuation}\"\n\nprint(greet(\"Alice\"))                    # (2)!\nprint(greet(\"Bob\", \"Hi\"))                # (3)!\nprint(greet(\"Charlie\", \"Hey\", \"...\"))    # Hey, Charlie...\n</code></pre> <ol> <li>Parameters with <code>=</code> have defaults\u2014<code>greeting</code> defaults to \"Hello\", <code>punctuation</code> to \"!\" if not provided</li> <li>Uses both defaults: \"Hello, Alice!\"</li> <li>Overrides first default but uses second: \"Hi, Bob!\"</li> </ol> <p>Mutable Default Arguments Trap</p> <p>Never use mutable objects (lists, dicts) as default values\u2014they're shared across all calls and cause subtle bugs!</p> The Bug<pre><code># DON'T do this:\ndef add_item(item, items=[]):  # (1)!\n    items.append(item)\n    return items\n\nprint(add_item(\"apple\"))   # ['apple'] \u2014 looks fine\nprint(add_item(\"banana\"))  # ['apple', 'banana'] \u2014 WHAT?!\n</code></pre> <ol> <li>The empty list is created once when the function is defined, not each time it's called\u2014all calls share the same list!</li> </ol> The Fix<pre><code># DO this instead:\ndef add_item(item, items=None):  # (1)!\n    if items is None:\n        items = []  # (2)!\n    items.append(item)\n    return items\n\nprint(add_item(\"apple\"))   # ['apple']\nprint(add_item(\"banana\"))  # ['banana'] \u2014 correct!\n</code></pre> <ol> <li>Use <code>None</code> as the sentinel value for \"no list provided\"</li> <li>Create a new list inside the function\u2014each call gets its own list</li> </ol>"},{"location":"basics/control_structures/functions/#keyword-arguments","title":"Keyword Arguments","text":"<p>Create users with optional flags. Configure functions with many parameters. Make calls self-documenting\u2014keyword arguments let you specify parameters by name:</p> Keyword Arguments<pre><code>def create_user(username: str, email: str, is_admin: bool = False, is_active: bool = True) -&gt; dict:  # (1)!\n    return {\n        \"username\": username,\n        \"email\": email,\n        \"is_admin\": is_admin,\n        \"is_active\": is_active\n    }\n\nuser = create_user(\"alice\", \"alice@example.com\", is_active=False)  # (2)!\nprint(user)  # {'username': 'alice', 'email': 'alice@example.com', 'is_admin': False, 'is_active': False}\n</code></pre> <ol> <li>Function has 2 required parameters and 2 optional parameters with defaults</li> <li>Specify <code>is_active</code> by name, skip <code>is_admin</code> (uses default <code>False</code>)\u2014keyword arguments make the call self-documenting</li> </ol>"},{"location":"basics/control_structures/functions/#args-variable-positional-arguments","title":"*args: Variable Positional Arguments","text":"<p>Sum any number of values. Concatenate multiple strings. Find the maximum of an unknown quantity of numbers\u2014<code>*args</code> accepts any number of positional arguments:</p> Variable Positional Arguments<pre><code>def sum_all(*numbers):  # (1)!\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3))         # 6\nprint(sum_all(10, 20, 30, 40))  # 100  (2)!\nprint(sum_all())                # 0   (3)!\n</code></pre> <ol> <li><code>*numbers</code> collects all positional arguments into a tuple named <code>numbers</code>\u2014you can pass 0, 1, or 100 arguments</li> <li>Four arguments \u2192 <code>numbers</code> becomes <code>(10, 20, 30, 40)</code></li> <li>Zero arguments \u2192 <code>numbers</code> becomes <code>()</code> (empty tuple)</li> </ol> <p>The name <code>args</code> is convention\u2014you could use <code>*values</code> or <code>*items</code>. The asterisk (<code>*</code>) is what triggers the behavior.</p> Mixing Required and *args<pre><code>def introduce(greeting: str, *names: str) -&gt; None:  # (1)!\n    for name in names:\n        print(f\"{greeting}, {name}!\")\n\nintroduce(\"Hello\", \"Alice\", \"Bob\", \"Charlie\")  # (2)!\n# Hello, Alice!\n# Hello, Bob!\n# Hello, Charlie!\n</code></pre> <ol> <li><code>greeting</code> is required, <code>*names</code> collects all remaining arguments\u2014must have at least one argument (the greeting)</li> <li>\"Hello\" fills <code>greeting</code>, the rest go into <code>names</code> tuple</li> </ol>"},{"location":"basics/control_structures/functions/#kwargs-variable-keyword-arguments","title":"**kwargs: Variable Keyword Arguments","text":"<p>Configuration functions. Building dictionaries from arguments. Flexible API wrappers\u2014<code>**kwargs</code> accepts any number of keyword arguments:</p> Variable Keyword Arguments<pre><code>def print_info(**kwargs):  # (1)!\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=30, city=\"New York\")  # (2)!\n# name: Alice\n# age: 30\n# city: New York\n</code></pre> <ol> <li><code>**kwargs</code> collects all keyword arguments into a dictionary named <code>kwargs</code></li> <li>Three keyword arguments \u2192 <code>kwargs</code> becomes <code>{\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}</code></li> </ol>"},{"location":"basics/control_structures/functions/#the-full-parameter-order","title":"The Full Parameter Order","text":"<p>When mixing parameter types, they must appear in this strict order:</p> Complete Parameter Order<pre><code>def complex_function(\n    required,           # (1)!\n    default=\"value\",    # (2)!\n    *args,              # (3)!\n    keyword_only=True,  # (4)!\n    **kwargs            # (5)!\n):\n    print(f\"Required: {required}\")\n    print(f\"Default: {default}\")\n    print(f\"Args: {args}\")\n    print(f\"Keyword only: {keyword_only}\")\n    print(f\"Kwargs: {kwargs}\")\n\ncomplex_function(\"hello\", \"world\", 1, 2, 3, keyword_only=False, extra=\"data\")\n# Required: hello\n# Default: world\n# Args: (1, 2, 3)\n# Keyword only: False\n# Kwargs: {'extra': 'data'}\n</code></pre> <ol> <li>Regular positional arguments\u2014must come first</li> <li>Parameters with defaults\u2014after required positionals</li> <li><code>*args</code> for variable positional\u2014collects extras into tuple</li> <li>Keyword-only parameters (after <code>*args</code>)\u2014can only be set by name</li> <li><code>**kwargs</code> for variable keyword\u2014always last, collects extras into dict</li> </ol> Common Patterns in Practice <p>You rarely need all five. The most common combinations:</p> <ul> <li><code>def f(a, b, c=None)</code> \u2014 required with optional defaults</li> <li><code>def f(*args)</code> \u2014 variable number of same-type items (sum, max, concatenate)</li> <li><code>def f(**kwargs)</code> \u2014 configuration functions, flexible APIs</li> <li><code>def f(*args, **kwargs)</code> \u2014 wrapper functions that forward everything to another function</li> </ul>"},{"location":"basics/control_structures/functions/#returning-multiple-values","title":"Returning Multiple Values","text":"<p>Get min and max in one call. Return status code and message. Calculate multiple statistics\u2014functions can return multiple values via tuple packing:</p> Tuple Packing for Multiple Returns<pre><code>def get_min_max(numbers: list[int]) -&gt; tuple[int, int]:  # (1)!\n    return min(numbers), max(numbers)  # (2)!\n\n# Unpack the returned tuple\nminimum, maximum = get_min_max([3, 1, 4, 1, 5, 9, 2, 6])  # (3)!\nprint(f\"Min: {minimum}, Max: {maximum}\")  # Min: 1, Max: 9\n\n# Or keep as tuple\nresult = get_min_max([3, 1, 4, 1, 5, 9, 2, 6])\nprint(result)  # (1, 9)\n</code></pre> <ol> <li>Type hint shows function returns a tuple of two integers</li> <li>Comma-separated values create a tuple\u2014<code>return min(numbers), max(numbers)</code> is equivalent to <code>return (min(numbers), max(numbers))</code></li> <li>Tuple unpacking assigns each returned value to a variable</li> </ol> Returning Structured Data<pre><code>def analyze_text(text: str) -&gt; dict:  # (1)!\n    words = text.split()\n    return {\n        \"word_count\": len(words),\n        \"char_count\": len(text),\n        \"unique_words\": len(set(words))\n    }\n\nstats = analyze_text(\"the quick brown fox jumps over the lazy dog\")\nprint(stats[\"word_count\"])  # 9\nprint(stats[\"unique_words\"])  # 8\n</code></pre> <ol> <li>Returning a dictionary provides named access to multiple values\u2014more self-documenting than tuples for complex data</li> </ol>"},{"location":"basics/control_structures/functions/#docstrings","title":"Docstrings","text":"<p>Document your functions. Explain parameters and return values. Provide usage examples\u2014docstrings are how Python functions document themselves:</p> Basic Docstring<pre><code>def calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"Calculate the area of a rectangle.\"\"\"  # (1)!\n    return length * width\n\nprint(calculate_area.__doc__)  # Calculate the area of a rectangle.\nhelp(calculate_area)  # Shows formatted documentation\n</code></pre> <ol> <li>Triple-quoted string immediately after function definition\u2014this is the docstring</li> </ol> <p>For complex functions, use multi-line docstrings with sections:</p> Detailed Docstring (Google Style)<pre><code>def calculate_bmi(weight_kg: float, height_m: float) -&gt; float:\n    \"\"\"\n    Calculate Body Mass Index (BMI).  # (1)!\n\n    Args:  # (2)!\n        weight_kg: Weight in kilograms.\n        height_m: Height in meters.\n\n    Returns:  # (3)!\n        The BMI value as a float.\n\n    Raises:  # (4)!\n        ValueError: If height is zero or negative.\n\n    Example:  # (5)!\n        &gt;&gt;&gt; calculate_bmi(70, 1.75)\n        22.857142857142858\n    \"\"\"\n    if height_m &lt;= 0:\n        raise ValueError(\"Height must be positive\")\n    return weight_kg / (height_m ** 2)\n</code></pre> <ol> <li>Brief summary on first line</li> <li>Args section documents each parameter</li> <li>Returns section describes the return value</li> <li>Raises section lists exceptions the function can raise</li> <li>Example section shows usage with expected output (doctest format)</li> </ol> Accessing Docstrings Programmatically <p>Access docstrings with <code>__doc__</code> attribute or <code>help()</code> function:</p> <pre><code>print(calculate_bmi.__doc__)  # Prints the docstring\nhelp(calculate_bmi)  # Displays formatted documentation\n</code></pre>"},{"location":"basics/control_structures/functions/#lambda-functions","title":"Lambda Functions","text":"<p>Sort by custom criteria. Transform data inline. Quick callback functions\u2014lambdas are anonymous, single-expression functions for short operations:</p> Lambda Syntax<pre><code># Regular function\ndef square(x: int) -&gt; int:\n    return x ** 2\n\n# Equivalent lambda\nsquare_lambda = lambda x: x ** 2  # (1)!\n\nprint(square(5))         # 25\nprint(square_lambda(5))  # 25\n</code></pre> <ol> <li>Lambda syntax: <code>lambda parameters: expression</code>\u2014no <code>def</code>, no <code>return</code>, single expression only</li> </ol>"},{"location":"basics/control_structures/functions/#where-lambdas-shine","title":"Where Lambdas Shine","text":"<p>Lambdas excel as arguments to functions like <code>sorted()</code>, <code>map()</code>, <code>filter()</code>:</p> Sorting with Lambda Keys<pre><code>students = [\n    {\"name\": \"Alice\", \"grade\": 85},\n    {\"name\": \"Bob\", \"grade\": 92},\n    {\"name\": \"Charlie\", \"grade\": 78}\n]\n\n# Sort by grade (ascending)\nby_grade = sorted(students, key=lambda s: s[\"grade\"])  # (1)!\nprint([s[\"name\"] for s in by_grade])  # ['Charlie', 'Alice', 'Bob']\n\n# Sort by name length (descending)\nby_name_length = sorted(students, key=lambda s: len(s[\"name\"]), reverse=True)\nprint([s[\"name\"] for s in by_name_length])  # ['Charlie', 'Alice', 'Bob']\n</code></pre> <ol> <li>The <code>key</code> parameter takes a function that extracts the sort value\u2014lambda provides an inline function without needing <code>def</code></li> </ol> map() and filter() with Lambdas<pre><code>numbers = [1, 2, 3, 4, 5]\n\n# Square each number\nsquared = list(map(lambda x: x ** 2, numbers))  # (1)!\nprint(squared)  # [1, 4, 9, 16, 25]\n\n# Filter for even numbers\nevens = list(filter(lambda x: x % 2 == 0, numbers))  # (2)!\nprint(evens)  # [2, 4]\n\n# But comprehensions are often cleaner!\nsquared = [x ** 2 for x in numbers]  # (3)!\nevens = [x for x in numbers if x % 2 == 0]\n</code></pre> <ol> <li><code>map()</code> applies the lambda to each element\u2014transforms [1, 2, 3] \u2192 [1, 4, 9]</li> <li><code>filter()</code> keeps only elements where the lambda returns <code>True</code></li> <li>List comprehensions are often more Pythonic than <code>map()</code>/<code>filter()</code> with lambdas</li> </ol> <p>Lambda Limitations</p> <p>Lambdas are limited to a single expression\u2014no statements, no assignments, no multiple lines. If you need <code>if</code>/<code>else</code> logic beyond a ternary expression, multiple operations, or better debugging, use a regular <code>def</code> function. PEP 8: \"Readability counts.\"</p>"},{"location":"basics/control_structures/functions/#variable-scope","title":"Variable Scope","text":"<p>Which variables can this function see? Can I modify that global counter? What happens when nested functions use the same name? Scope rules determine where variables are accessible:</p>"},{"location":"basics/control_structures/functions/#local-scope","title":"Local Scope","text":"<p>Variables defined inside a function exist only within that function:</p> Local Scope<pre><code>def my_function():\n    message = \"I'm local!\"  # (1)!\n    print(message)\n\nmy_function()  # I'm local!\n# print(message)  # (2)!\n</code></pre> <ol> <li><code>message</code> only exists inside <code>my_function</code>\u2014created when function runs, destroyed when it returns</li> <li>Would raise <code>NameError: name 'message' is not defined</code>\u2014<code>message</code> doesn't exist outside the function</li> </ol>"},{"location":"basics/control_structures/functions/#global-scope","title":"Global Scope","text":"<p>Variables defined at module level are accessible everywhere:</p> Global Scope<pre><code>greeting = \"Hello\"  # (1)!\n\ndef say_hello(name: str) -&gt; None:\n    print(f\"{greeting}, {name}!\")  # (2)!\n\nsay_hello(\"World\")  # Hello, World!\n</code></pre> <ol> <li><code>greeting</code> is global\u2014defined outside any function</li> <li>Functions can read global variables\u2014<code>greeting</code> is accessible here</li> </ol>"},{"location":"basics/control_structures/functions/#modifying-global-variables","title":"Modifying Global Variables","text":"<p>To modify a global variable inside a function, explicitly declare it with <code>global</code>:</p> The global Keyword<pre><code>counter = 0\n\ndef increment():\n    global counter  # (1)!\n    counter += 1\n\nincrement()\nincrement()\nprint(counter)  # 2\n</code></pre> <ol> <li><code>global counter</code> tells Python \"I want to modify the global <code>counter</code>, not create a new local one\"\u2014without this, <code>counter += 1</code> would raise <code>UnboundLocalError</code></li> </ol> <p>Global Variables Are Code Smell</p> <p>Modifying global variables makes code hard to test and reason about\u2014functions have hidden dependencies. Prefer returning values and passing parameters. If you're using <code>global</code> frequently, refactor to classes or pass state explicitly.</p>"},{"location":"basics/control_structures/functions/#the-nonlocal-keyword","title":"The <code>nonlocal</code> Keyword","text":"<p>For nested functions, <code>nonlocal</code> modifies variables from enclosing (non-global) scopes:</p> nonlocal for Nested Functions<pre><code>def outer():\n    count = 0  # (1)!\n\n    def inner():\n        nonlocal count  # (2)!\n        count += 1\n        print(f\"Count: {count}\")\n\n    inner()  # Count: 1\n    inner()  # Count: 2\n    inner()  # Count: 3\n\nouter()\n</code></pre> <ol> <li><code>count</code> is in the enclosing scope\u2014not global, not local to <code>inner</code></li> <li><code>nonlocal count</code> allows <code>inner</code> to modify <code>outer</code>'s <code>count</code> variable</li> </ol>"},{"location":"basics/control_structures/functions/#scope-lookup-order-legb-rule","title":"Scope Lookup Order (LEGB Rule)","text":"<p>Python searches for names in this order:</p> <ol> <li>Local\u2014inside the current function</li> <li>Enclosing\u2014in enclosing functions (for nested functions)</li> <li>Global\u2014at the module level</li> <li>Built-in\u2014Python's built-in names (<code>print</code>, <code>len</code>, etc.)</li> </ol> LEGB in Action<pre><code>x = \"global\"\n\ndef outer():\n    x = \"enclosing\"  # (1)!\n\n    def inner():\n        x = \"local\"  # (2)!\n        print(x)  # local\n\n    inner()\n    print(x)  # enclosing\n\nouter()\nprint(x)  # global\n</code></pre> <ol> <li>Each function can have its own <code>x</code> variable\u2014they don't conflict</li> <li>Python finds the innermost (most local) <code>x</code> first\u2014prints \"local\", not \"enclosing\" or \"global\"</li> </ol>"},{"location":"basics/control_structures/functions/#type-hints","title":"Type Hints","text":"<p>Document expected types. Enable IDE autocompletion. Catch type errors before runtime\u2014type hints make Python code more maintainable:</p> Type Hints Basics<pre><code>def greet(name: str) -&gt; str:  # (1)!\n    return f\"Hello, {name}!\"\n\ndef add_numbers(a: int, b: int) -&gt; int:\n    return a + b\n\ndef process_items(items: list[str]) -&gt; dict[str, int]:  # (2)!\n    return {item: len(item) for item in items}\n</code></pre> <ol> <li><code>name: str</code> means parameter expects a string, <code>-&gt; str</code> means function returns a string</li> <li>Generic types like <code>list[str]</code> specify the type of elements\u2014list of strings \u2192 dictionary of string keys to integer values</li> </ol> <p>Type hints are optional and don't affect runtime\u2014Python won't raise errors for wrong types. They're primarily for:</p> <ul> <li>Documentation: Makes function signatures self-documenting</li> <li>IDE support: Enables autocompletion and inline error checking</li> <li>Static analysis: Tools like <code>mypy</code> catch type errors before runtime</li> <li>Refactoring: Easier to understand what changes might break</li> </ul> Optional and Union Types<pre><code>from typing import Optional\n\ndef find_user(user_id: int) -&gt; Optional[dict]:  # (1)!\n    \"\"\"Return user dict or None if not found.\"\"\"\n    if user_id == 1:\n        return {\"name\": \"Alice\"}\n    return None\n\ndef process(value: int | str) -&gt; str:  # (2)!\n    \"\"\"Accept either int or str.\"\"\"\n    return str(value)\n</code></pre> <ol> <li><code>Optional[dict]</code> means \"either a dict or None\"\u2014shorthand for <code>dict | None</code></li> <li><code>int | str</code> means \"either an int or a str\" (Python 3.10+ syntax, cleaner than <code>Union[int, str]</code>)</li> </ol>"},{"location":"basics/control_structures/functions/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Default parameters <code>def f(x, y=10)</code> \u2014 defaults come after required Keyword arguments <code>f(y=5, x=3)</code> \u2014 specify by name *args Collect extra positional args into a tuple **kwargs Collect extra keyword args into a dict Multiple returns <code>return a, b</code> \u2014 returns a tuple Docstrings <code>\"\"\"Documentation\"\"\"</code> right after <code>def</code> Lambda <code>lambda x: x * 2</code> \u2014 anonymous single-expression function Local scope Variables inside function aren't visible outside global Declare intent to modify a global variable nonlocal Modify variable from enclosing function scope Type hints <code>def f(x: int) -&gt; str:</code> \u2014 for documentation and tools"},{"location":"basics/control_structures/functions/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Default Parameters <p>What will this code print?</p> <pre><code>def greet(name, prefix=\"Hello\"):\n    return f\"{prefix}, {name}!\"\n\nprint(greet(\"Alice\"))\nprint(greet(\"Bob\", \"Hi\"))\n</code></pre> Answer <pre><code>Hello, Alice!\nHi, Bob!\n</code></pre> <p>The first call uses the default <code>prefix</code> (\"Hello\"). The second call overrides it with \"Hi\".</p> Practice Problem 2: *args <p>What's the difference between these two functions?</p> <pre><code>def sum_list(numbers):\n    return sum(numbers)\n\ndef sum_args(*numbers):\n    return sum(numbers)\n</code></pre> Answer <ul> <li><code>sum_list()</code> takes a single argument (a list): <code>sum_list([1, 2, 3])</code></li> <li><code>sum_args()</code> takes variable positional arguments: <code>sum_args(1, 2, 3)</code></li> </ul> <p>Both work internally the same way (summing a sequence), but the calling interface differs. <code>*args</code> collects multiple arguments into a tuple.</p> Practice Problem 3: Scope <p>What does this code print?</p> <pre><code>x = 10\n\ndef modify_x():\n    x = 20\n    print(x)\n\nmodify_x()\nprint(x)\n</code></pre> Answer <pre><code>20\n10\n</code></pre> <p>The function creates a local variable <code>x = 20</code>, which only exists inside the function. The global <code>x</code> remains unchanged at <code>10</code>. To modify the global, you'd need <code>global x</code> inside the function.</p> Practice Problem 4: Lambda Functions <p>Rewrite this using a lambda function:</p> <pre><code>def double(x):\n    return x * 2\n\nnumbers = [1, 2, 3, 4]\ndoubled = list(map(double, numbers))\n</code></pre> Answer <pre><code>numbers = [1, 2, 3, 4]\ndoubled = list(map(lambda x: x * 2, numbers))\n</code></pre> <p>Or even better with a list comprehension:</p> <pre><code>doubled = [x * 2 for x in numbers]\n</code></pre>"},{"location":"basics/control_structures/functions/#further-reading","title":"Further Reading","text":"<ul> <li>Python Functions Tutorial - Official documentation on functions</li> <li>PEP 8 \u2013 Style Guide - Function naming conventions and best practices</li> <li>PEP 257 \u2013 Docstring Conventions - How to write good docstrings</li> <li>PEP 484 \u2013 Type Hints - Introduction to type hints in Python</li> <li>PEP 3107 \u2013 Function Annotations - The proposal that introduced function annotations</li> <li>Computational Thinking: Abstraction - Understanding functions as abstraction mechanisms</li> </ul> <p>Functions are the building blocks of organized, reusable code. They transform repetitive tasks into single, named operations. They enable testing, collaboration, and maintainability. Every complex program is built from simple functions composed together.</p> <p>Master the fundamentals: parameters, return values, scope. Understand the advanced features: <code>*args</code>, <code>**kwargs</code>, decorators, closures. Write clear docstrings, use type hints, follow PEP 8 naming conventions. A well-written function does one thing, does it well, and has a name that clearly communicates its purpose.</p> <p>The difference between a script and a program is organization. Functions are how you organize code.</p>"},{"location":"basics/control_structures/if_statements/","title":"<code>if</code> Statements","text":"<p>Grant admin access only if credentials match. Charge shipping fees based on order total and destination. Display different error messages depending on what went wrong. Calculate letter grades from numeric scores. Route HTTP requests to different handlers based on the URL path.</p> <p>Every one of these requires your program to choose between different paths of execution. That's what <code>if</code> statements enable: conditional logic that makes programs adaptive, responsive, and intelligent. They're the foundation of control flow\u2014the ability to make decisions based on conditions.</p>"},{"location":"basics/control_structures/if_statements/#what-is-an-if-statement","title":"What is an If Statement?","text":"<p>An <code>if</code> statement evaluates a boolean condition and executes a block of code only when that condition is <code>True</code>:</p> Basic If Statement<pre><code>age = 25\nif age &gt;= 18:  # (1)!\n    print(\"You can vote!\")\n</code></pre> <ol> <li>The condition <code>age &gt;= 18</code> evaluates to <code>True</code> or <code>False</code>\u2014if <code>True</code>, the indented block executes</li> </ol> <p>You can extend this with <code>elif</code> (else if) to check multiple conditions in sequence, and <code>else</code> to handle cases where none of the conditions matched:</p> If-Elif-Else Structure<pre><code>score = 85\n\nif score &gt;= 90:  # (1)!\n    print(\"A\")\nelif score &gt;= 80:  # (2)!\n    print(\"B\")\nelif score &gt;= 70:\n    print(\"C\")\nelse:  # (3)!\n    print(\"F\")\n</code></pre> <ol> <li>Checks the first condition\u2014if <code>True</code>, prints \"A\" and skips the rest</li> <li>Only evaluated if the previous <code>if</code> was <code>False</code>\u2014checks conditions in order</li> <li>The fallback\u2014executes only if all previous conditions were <code>False</code></li> </ol>"},{"location":"basics/control_structures/if_statements/#why-if-statements-matter","title":"Why If Statements Matter","text":"<p>If statements transform static code into adaptive programs:</p> <ul> <li>Access control: Check permissions before allowing operations\u2014authentication, authorization, admin features</li> <li>Input validation: Verify data meets requirements before processing\u2014email format, password strength, age restrictions</li> <li>Error handling: Different responses based on what went wrong\u2014404 vs 500 errors, network failures vs invalid input</li> <li>Business logic: Calculate pricing, apply discounts, determine shipping costs based on complex rules</li> <li>State management: Different behavior based on current state\u2014game over vs playing, logged in vs logged out</li> <li>Data filtering: Include or exclude items based on criteria\u2014search results, active users, valid transactions</li> </ul> <p>Without conditional logic, every program would execute the same way every time. If statements enable programs to respond to their environment.</p>"},{"location":"basics/control_structures/if_statements/#common-patterns","title":"Common Patterns","text":""},{"location":"basics/control_structures/if_statements/#simple-if-else-binary-decisions","title":"Simple If-Else: Binary Decisions","text":"<p>Check a score threshold. Validate user age. Test if a file exists\u2014any yes/no decision:</p> Game Win Condition<pre><code>player_score = 47\nwinning_score = 100\n\nif player_score &gt;= winning_score:  # (1)!\n    print(\"YOU WIN!\")\nelse:\n    print(f\"You need {winning_score - player_score} more points to win!\")  # (2)!\n</code></pre> <ol> <li>Simple comparison\u2014<code>True</code> if player has reached or exceeded the threshold</li> <li>F-string calculates the remaining points needed\u2014output: \"You need 53 more points to win!\"</li> </ol>"},{"location":"basics/control_structures/if_statements/#combining-conditions-andor-logic","title":"Combining Conditions: AND/OR Logic","text":"<p>Authenticate users. Check multiple requirements. Validate complex eligibility\u2014combine boolean operators:</p> User Authentication<pre><code>user_input_username = \"john_doe\"\nuser_input_password = \"secure_password\"\n\ncorrect_username = \"john_doe\"\ncorrect_password = \"secure_password\"\n\nif user_input_username == correct_username and \\\n   user_input_password == correct_password:  # (1)!\n    print(\"Access granted!\")\nelse:\n    print(\"Access denied. Please check your username and password.\")\n</code></pre> <ol> <li>Both conditions must be <code>True</code>\u2014the backslash (<code>\\</code>) continues the line for readability. You could also write this on one line or use parentheses.</li> </ol>"},{"location":"basics/control_structures/if_statements/#multiple-conditions-if-elif-else-chains","title":"Multiple Conditions: If-Elif-Else Chains","text":"<p>Grade assignment. Tax brackets. Shipping zones. Priority levels\u2014sequential condition checking:</p> Grade Calculation<pre><code>student_score = 85\n\nif student_score &gt;= 90:  # (1)!\n    grade = \"A\"\nelif student_score &gt;= 80:  # (2)!\n    grade = \"B\"\nelif student_score &gt;= 70:\n    grade = \"C\"\nelif student_score &gt;= 60:\n    grade = \"D\"\nelse:  # (3)!\n    grade = \"F\"\n\nprint(f\"Grade: {grade}\")  # Grade: B\n</code></pre> <ol> <li>Python checks conditions from top to bottom\u2014first match wins</li> <li>Only checked if the <code>if</code> (and any preceding <code>elif</code>) failed\u2014order matters!</li> <li>The catch-all\u2014executes if no previous condition matched</li> </ol>"},{"location":"basics/control_structures/if_statements/#nested-conditionals","title":"Nested Conditionals","text":"<p>Check driver eligibility (age, license, insurance). Process payments (valid card, sufficient funds, fraud check). Validate forms (all fields present, correct format, unique email). Sometimes one decision leads to another:</p> Nested If Statements<pre><code>age = 25\nhas_license = True\nhas_insurance = True\n\nif age &gt;= 16:  # (1)!\n    if has_license:\n        if has_insurance:\n            print(\"You can drive!\")\n        else:\n            print(\"You need insurance first.\")\n    else:\n        print(\"You need a license first.\")\nelse:\n    print(\"You're too young to drive.\")\n</code></pre> <ol> <li>Three levels of nesting\u2014each decision depends on the previous one being <code>True</code></li> </ol> <p>While nesting works, too many levels make code hard to follow. Flatten with boolean operators or use guard clauses in functions:</p> Flattened Conditionals<pre><code># More readable alternative using 'and'\nif age &gt;= 16 and has_license and has_insurance:  # (1)!\n    print(\"You can drive!\")\nelif age &lt; 16:\n    print(\"You're too young to drive.\")\nelif not has_license:\n    print(\"You need a license first.\")\nelse:\n    print(\"You need insurance first.\")\n</code></pre> <ol> <li>Single condition combining all requirements\u2014easier to read and test</li> </ol> <p>Avoid Deep Nesting</p> <p>Nesting more than 2-3 levels deep usually signals a need to refactor. Extract functions, combine conditions with <code>and</code>/<code>or</code>, or use early returns.</p>"},{"location":"basics/control_structures/if_statements/#the-ternary-operator-conditional-expression","title":"The Ternary Operator (Conditional Expression)","text":"<p>Set default values. Format output based on a condition. Assign variables conditionally in one line\u2014the ternary operator handles simple either/or logic concisely:</p> Ternary Operator Basics<pre><code># Traditional if-else\nage = 20\nif age &gt;= 18:\n    status = \"adult\"\nelse:\n    status = \"minor\"\n\n# Same logic as a ternary expression\nstatus = \"adult\" if age &gt;= 18 else \"minor\"  # (1)!\nprint(status)  # adult\n</code></pre> <ol> <li>Syntax: <code>value_if_true if condition else value_if_false</code>\u2014condition is evaluated, then one of the two values is returned</li> </ol> Practical Ternary Examples<pre><code># Setting defaults\nname = user_input if user_input else \"Anonymous\"  # (1)!\n\n# Quick formatting\nscore = 85\ngrade = \"Pass\" if score &gt;= 60 else \"Fail\"  # (2)!\n\n# Nested ternary (use sparingly!)\ngrade = \"A\" if score &gt;= 90 else \"B\" if score &gt;= 80 else \"C\" if score &gt;= 70 else \"F\"  # (3)!\n</code></pre> <ol> <li>If <code>user_input</code> is truthy, use it; otherwise default to \"Anonymous\"\u2014leverages truthiness</li> <li>Binary decision\u2014pass/fail based on threshold</li> <li>Multiple conditions chained\u2014works but quickly becomes hard to read</li> </ol> <p>When to Avoid Ternaries</p> <p>Ternary expressions are elegant for simple either/or logic. Chaining them (nested ternaries) sacrifices readability. If you need multiple conditions, use <code>if-elif-else</code> instead. PEP 8 emphasizes: \"Readability counts.\"</p>"},{"location":"basics/control_structures/if_statements/#match-statements-python-310","title":"Match Statements (Python 3.10+)","text":"<p>Parse HTTP status codes. Route commands. Handle event types. Process structured data. Python 3.10 introduced <code>match</code> statements\u2014pattern matching that goes far beyond simple equality checks:</p> Basic Match Statement<pre><code>def http_status(status):\n    match status:  # (1)!\n        case 200:\n            return \"OK\"\n        case 404:\n            return \"Not Found\"\n        case 500:\n            return \"Internal Server Error\"\n        case _:  # (2)!\n            return \"Unknown status\"\n\nprint(http_status(200))  # OK\nprint(http_status(418))  # Unknown status\n</code></pre> <ol> <li>The <code>match</code> statement evaluates <code>status</code> once, then checks it against each <code>case</code> pattern</li> <li>The underscore (<code>_</code>) is a wildcard\u2014matches anything not caught by previous cases (like <code>else</code> in if-elif-else)</li> </ol>"},{"location":"basics/control_structures/if_statements/#matching-multiple-values","title":"Matching Multiple Values","text":"<p>Weekend vs weekday logic. Categorizing user roles. Grouping similar cases\u2014the pipe operator (<code>|</code>) matches any of several values:</p> Matching Multiple Values<pre><code>def classify_day(day):\n    match day.lower():\n        case \"saturday\" | \"sunday\":  # (1)!\n            return \"Weekend!\"\n        case \"monday\" | \"tuesday\" | \"wednesday\" | \"thursday\" | \"friday\":\n            return \"Weekday\"\n        case _:\n            return \"Not a valid day\"\n\nprint(classify_day(\"Saturday\"))  # Weekend!\n</code></pre> <ol> <li>The pipe (<code>|</code>) operator means \"or\"\u2014matches if the value equals any of the options listed</li> </ol>"},{"location":"basics/control_structures/if_statements/#matching-with-guards","title":"Matching with Guards","text":"<p>Categorize numbers by properties. Filter data based on conditions. Add complex validation\u2014guards combine pattern matching with conditional logic:</p> Match with Guards<pre><code>def categorize_number(n):\n    match n:\n        case n if n &lt; 0:  # (1)!\n            return \"Negative\"\n        case 0:  # (2)!\n            return \"Zero\"\n        case n if n % 2 == 0:\n            return \"Positive even\"\n        case _:\n            return \"Positive odd\"\n\nprint(categorize_number(-5))   # Negative\nprint(categorize_number(0))    # Zero\nprint(categorize_number(4))    # Positive even\nprint(categorize_number(7))    # Positive odd\n</code></pre> <ol> <li>The <code>if</code> after the pattern is a guard\u2014pattern matches any value, but only proceeds if <code>n &lt; 0</code></li> <li>Exact value match\u2014no guard needed for simple equality</li> </ol>"},{"location":"basics/control_structures/if_statements/#matching-sequences-and-structures","title":"Matching Sequences and Structures","text":"<p>Parse command strings. Process API responses. Route structured data. Destructure tuples and lists\u2014<code>match</code> excels at pattern matching complex data:</p> Matching List Patterns<pre><code>def process_command(command):\n    match command.split():  # (1)!\n        case [\"quit\"]:\n            return \"Goodbye!\"\n        case [\"hello\", name]:  # (2)!\n            return f\"Hello, {name}!\"\n        case [\"add\", x, y]:\n            return f\"Result: {int(x) + int(y)}\"\n        case [\"move\", direction, steps]:\n            return f\"Moving {direction} by {steps} steps\"\n        case _:\n            return \"Unknown command\"\n\nprint(process_command(\"quit\"))           # Goodbye!\nprint(process_command(\"hello World\"))    # Hello, World!\nprint(process_command(\"add 5 3\"))        # Result: 8\n</code></pre> <ol> <li>Splits the string into a list, then matches against list patterns</li> <li>Matches a 2-element list where first element is \"hello\"\u2014second element is captured in variable <code>name</code></li> </ol> Matching Dictionary Patterns<pre><code>def handle_event(event):\n    match event:\n        case {\"type\": \"click\", \"x\": x, \"y\": y}:  # (1)!\n            return f\"Click at ({x}, {y})\"\n        case {\"type\": \"keypress\", \"key\": key}:\n            return f\"Key pressed: {key}\"\n        case {\"type\": \"scroll\", \"direction\": d}:\n            return f\"Scrolling {d}\"\n        case _:\n            return \"Unknown event\"\n\nprint(handle_event({\"type\": \"click\", \"x\": 100, \"y\": 200}))  # Click at (100, 200)\nprint(handle_event({\"type\": \"keypress\", \"key\": \"Enter\"}))   # Key pressed: Enter\n</code></pre> <ol> <li>Matches dictionaries with specific keys\u2014values are captured into variables</li> </ol> When to Use Match vs If-Elif <p><code>match</code> excels at:</p> <ul> <li>Handling multiple specific values (HTTP status codes, command types, state values)</li> <li>Destructuring complex data structures (lists, dicts, tuples from APIs or parsed data)</li> <li>Making state machines and command parsers more readable</li> <li>Pattern matching with guards for complex filtering</li> </ul> <p>Use <code>if-elif-else</code> for:</p> <ul> <li>Simple boolean conditions and range checks</li> <li>Code that needs to run on Python &lt;3.10</li> <li>When you don't need destructuring or pattern matching</li> </ul>"},{"location":"basics/control_structures/if_statements/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Basic If-Else <p>What will this code print?</p> <pre><code>temperature = 25\nif temperature &gt; 30:\n    print(\"Hot\")\nelif temperature &gt; 20:\n    print(\"Warm\")\nelse:\n    print(\"Cold\")\n</code></pre> Answer <p>It prints <code>\"Warm\"</code>.</p> <p>The first condition (<code>temperature &gt; 30</code>) is <code>False</code> (25 is not greater than 30). Python then checks the <code>elif</code> condition (<code>temperature &gt; 20</code>), which is <code>True</code> (25 &gt; 20), so it prints \"Warm\" and skips the <code>else</code> block.</p> Practice Problem 2: Ternary Operator <p>Rewrite this if-else block as a ternary expression:</p> <pre><code>x = 15\nif x % 2 == 0:\n    result = \"even\"\nelse:\n    result = \"odd\"\n</code></pre> Answer <pre><code>x = 15\nresult = \"even\" if x % 2 == 0 else \"odd\"\n</code></pre> <p>The ternary syntax is: <code>value_if_true if condition else value_if_false</code>. Since <code>x % 2 == 0</code> is the condition, \"even\" is returned if true, \"odd\" if false.</p> Practice Problem 3: Nested vs Flattened <p>Why is the second version better than the first?</p> <pre><code># Version 1\nif age &gt;= 18:\n    if has_id:\n        if not is_banned:\n            print(\"Entry allowed\")\n\n# Version 2\nif age &gt;= 18 and has_id and not is_banned:\n    print(\"Entry allowed\")\n</code></pre> Answer <p>Version 2 is better because:</p> <ul> <li>Readability: Single line condition is easier to understand than 3 levels of nesting</li> <li>Maintainability: Easier to modify or add conditions</li> <li>Pythonic: Combining conditions with <code>and</code>/<code>or</code> is idiomatic Python</li> </ul> <p>Version 1 forces you to track indentation levels to understand the logic. Version 2 makes all requirements explicit in one place.</p> Practice Problem 4: Match Statements <p>What does this match statement do differently than an if-elif chain?</p> <pre><code>match command.split():\n    case [\"move\", direction, steps]:\n        move(direction, int(steps))\n    case [\"quit\"]:\n        exit()\n</code></pre> Answer <p>The match statement destructures the list and captures values into variables.</p> <ul> <li><code>[\"move\", direction, steps]</code> matches a 3-element list where the first element is \"move\", then captures the second and third elements into <code>direction</code> and <code>steps</code> variables</li> <li>An if-elif chain would need manual indexing: <code>if parts[0] == \"move\": direction = parts[1]; steps = parts[2]</code></li> </ul> <p>This destructuring makes parsing structured data much cleaner than traditional conditionals.</p>"},{"location":"basics/control_structures/if_statements/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember if-elif-else The workhorse of decision-making Nested conditionals Useful but flatten when possible Ternary operator <code>value_if_true if condition else value_if_false</code> match (3.10+) Pattern matching with destructuring Wildcard <code>_</code> Matches anything in match statements Guards Add <code>if</code> conditions to match cases"},{"location":"basics/control_structures/if_statements/#further-reading","title":"Further Reading","text":"<ul> <li>Python If Statements Documentation - Official tutorial on conditional statements</li> <li>PEP 622 \u2013 Structural Pattern Matching - The proposal that introduced match statements in Python 3.10</li> <li>PEP 634 \u2013 Structural Pattern Matching: Specification - Complete specification for match syntax</li> <li>PEP 8 \u2013 Style Guide - Best practices for writing conditionals</li> <li>Computational Thinking - Understanding control flow and decision-making in algorithms</li> </ul> <p>Conditionals are the decision-making heart of every program. Without them, code executes linearly, the same way every time\u2014deterministic but inflexible. <code>if</code> statements introduce adaptability, enabling programs to respond to data, user input, and changing conditions.</p> <p>Master the fundamentals: <code>if-elif-else</code> for sequential conditions, ternary operators for simple assignments, nested conditionals flattened with boolean logic. Then level up with Python 3.10's <code>match</code> statements\u2014pattern matching that destructures data structures elegantly. Each approach has its place: use the simplest tool that clearly expresses your intent. Readability counts.</p>"},{"location":"basics/control_structures/while_loops/","title":"While Loops","text":"<p>Unlike <code>for</code> loops, <code>while</code> loops are non-deterministic \u2013 the program (and programmer!) doesn't always know how many times the loop will repeat before it finally calls it quits. Instead, it depends on a particular condition \u2013 usually waiting for a <code>boolean</code> to flip from <code>True</code> to <code>False</code>. \ud83d\udd75\ufe0f\u200d\u2642\ufe0f</p> Danger <p>If the condition never becomes <code>False</code>, an infinite loop can be created. If you encounter  an infinite loop, usually <code>Ctrl+C</code> will kill the program (for basic scripting).  (Don't worry, it happens to everyone! Even the pros forget to escape sometimes. \ud83c\udfc3\u200d\u2642\ufe0f\ud83d\udca8)</p> <p>The basic form of a <code>while</code> loop is:</p> Basic While Loop<pre><code>while expr:\n    &lt;code block&gt;\n</code></pre> <p>The expression is evaluated at the start of each loop, and if it is <code>True</code>, the loop will run. It's like a party that keeps going as long as the music is playing! \ud83c\udfb6</p> <p>For example:</p> Loop Until \"Exit\"<pre><code>keep_looping = True\nwhile keep_looping:\n    user_input = input(\"Enter 'exit' to stop the loop: \")\n    if user_input.lower() == 'exit':\n        print(\"Exiting the loop. Goodbye! \ud83d\udc4b\")\n        keep_looping = False\n    else:\n        print(f\"You entered: {user_input} \ud83e\udd16\")\n</code></pre> <p>Until the user enters \"exit\", this loop will keep echoing the user input infinitely. Careful not to get stuck in an infinite loop.</p> Tip <p>It is possible that a <code>while</code> loop will never run if, when it is reached, the condition  it checks is already <code>False</code>. \ud83d\udeab</p> <p>Another common pattern is to check equality and increment/decrement the value on each iteration:</p> Loop Until Value is Zero<pre><code>value = 10\n\nwhile value &gt; 0:\n    print(f\"Current value: {value}\")\n    value -= 1  # Decrease the value by 1 each iteration\nprint(\"Loop has ended. All done! \ud83c\udfc1\")\n</code></pre>"},{"location":"basics/control_structures/while_loops/#the-while-true-pattern","title":"The <code>while True</code> Pattern","text":"<p>One of the most common patterns is <code>while True</code> with an explicit <code>break</code> to exit. This is perfect when you don't know up front how many iterations you'll need:</p> While True with Break<pre><code>while True:\n    user_input = input(\"Enter a number (or 'quit' to exit): \")\n\n    if user_input.lower() == 'quit':\n        print(\"Goodbye! \ud83d\udc4b\")\n        break\n\n    try:\n        number = int(user_input)\n        print(f\"You entered: {number}\")\n    except ValueError:\n        print(\"That's not a valid number. Try again!\")\n</code></pre> <p>This reads as: \"Keep looping forever, until we explicitly break out.\" It's cleaner than managing a separate boolean flag in many cases.</p>"},{"location":"basics/control_structures/while_loops/#input-validation-loop","title":"Input Validation Loop","text":"<p>A classic use case \u2014 keep asking until the user gives valid input. Like a barista who won't let you leave without confirming your order. \u2615</p> Input Validation<pre><code>while True:\n    age_str = input(\"Enter your age: \")\n\n    if not age_str.isdigit():\n        print(\"\u274c Please enter a valid number.\")\n        continue\n\n    age = int(age_str)\n\n    if age &lt; 0 or age &gt; 150:\n        print(\"\u274c That doesn't seem like a realistic age...\")\n        continue\n\n    # If we get here, input is valid!\n    break\n\nprint(f\"\u2705 Got it! You are {age} years old.\")\n</code></pre> <p>Validation Pattern</p> <p>The pattern is: loop forever, <code>continue</code> on bad input (to retry), <code>break</code> on good input. Simple and effective. \ud83c\udfaf</p>"},{"location":"basics/control_structures/while_loops/#sentinel-value-pattern","title":"Sentinel Value Pattern","text":"<p>Sometimes you loop until you encounter a special \"sentinel\" value that signals the end:</p> Sentinel Value<pre><code>print(\"Enter numbers to sum (enter 0 to finish):\")\ntotal = 0\n\nwhile True:\n    num = int(input(\"Number: \"))\n    if num == 0:  # Sentinel value\n        break\n    total += num\n\nprint(f\"Sum: {total}\")\n</code></pre> <p>Common sentinel values include <code>0</code>, <code>-1</code>, empty string <code>\"\"</code>, or <code>None</code>.</p>"},{"location":"basics/control_structures/while_loops/#processing-until-exhausted","title":"Processing Until Exhausted","text":"<p>While loops excel when you're consuming from a source until it's empty:</p> Processing a Stack<pre><code>tasks = [\"Write code\", \"Review PR\", \"Deploy\", \"Test\"]\n\nwhile tasks:  # Truthy check \u2014 empty list is False\n    current_task = tasks.pop()\n    print(f\"Working on: {current_task}\")\n    print(f\"  (Tasks remaining: {len(tasks)})\")\n\nprint(\"All done! \ud83c\udf89\")\n</code></pre> <p>Returns:</p> <pre><code>Working on: Test\n  (Tasks remaining: 3)\nWorking on: Deploy\n  (Tasks remaining: 2)\nWorking on: Review PR\n  (Tasks remaining: 1)\nWorking on: Write code\n  (Tasks remaining: 0)\nAll done! \ud83c\udf89\n</code></pre>"},{"location":"basics/control_structures/while_loops/#retry-with-limits","title":"Retry with Limits","text":"<p>Don't let your program try forever \u2014 add a maximum attempt count:</p> Retry with Maximum Attempts<pre><code>import random\n\nmax_attempts = 3\nattempts = 0\n\nwhile attempts &lt; max_attempts:\n    attempts += 1\n    password = input(f\"Enter password (attempt {attempts}/{max_attempts}): \")\n\n    if password == \"secret123\":\n        print(\"\u2705 Access granted!\")\n        break\n    else:\n        print(\"\u274c Wrong password.\")\nelse:\n    # This runs if we exit normally (no break) \u2014 meaning all attempts failed\n    print(\"\ud83d\udd12 Account locked. Too many failed attempts.\")\n</code></pre> <p>The else Clause</p> <p>Just like <code>for</code> loops, <code>while</code> loops can have an <code>else</code> clause. It runs only if the loop completes normally (without a <code>break</code>). See Controlling Loops for more.</p>"},{"location":"basics/control_structures/while_loops/#waiting-for-a-condition","title":"Waiting for a Condition","text":"<p>While loops are great for polling or waiting:</p> Waiting for a Condition<pre><code>import time\n\n# Simulating waiting for a resource\nretries = 0\nmax_retries = 5\nresource_ready = False\n\nwhile not resource_ready and retries &lt; max_retries:\n    print(f\"Checking resource... (attempt {retries + 1})\")\n    # In real code, you'd check an actual condition here\n    retries += 1\n    time.sleep(0.5)  # Wait half a second\n\n    if retries &gt;= 3:  # Simulate resource becoming ready\n        resource_ready = True\n\nif resource_ready:\n    print(\"Resource is ready! \u2705\")\nelse:\n    print(\"Resource never became ready \ud83d\ude1e\")\n</code></pre>"},{"location":"basics/control_structures/while_loops/#intentional-infinite-loops","title":"Intentional Infinite Loops","text":"<p>Some programs should run forever \u2014 like servers, game loops, or monitoring scripts:</p> Game Loop (Conceptual)<pre><code># A simplified game loop structure\nrunning = True\n\nwhile running:\n    # 1. Handle input\n    # events = get_events()\n\n    # 2. Update game state\n    # update_game(events)\n\n    # 3. Render\n    # draw_screen()\n\n    # 4. Check for quit\n    # if quit_requested:\n    #     running = False\n    pass  # In a real game, this would be the loop content\n</code></pre> Simple Server Loop (Conceptual)<pre><code># Conceptual \u2014 real servers use frameworks\nwhile True:\n    # connection = wait_for_connection()\n    # request = read_request(connection)\n    # response = process_request(request)\n    # send_response(connection, response)\n    pass\n</code></pre> <p>Breaking Out of Infinite Loops</p> <p>During development, if you accidentally create an infinite loop:</p> <ul> <li>In a terminal: Press <code>Ctrl+C</code> to send a keyboard interrupt</li> <li>In an IDE: Use the stop/kill button</li> <li>As a last resort: Force quit the process</li> </ul> <p>This happens to everyone. It's practically a rite of passage. \ud83c\udf93</p>"},{"location":"basics/control_structures/while_loops/#for-vs-while-when-to-use-each","title":"for vs while: When to Use Each","text":"Use <code>for</code> when... Use <code>while</code> when... Iterating over a known sequence Number of iterations is unknown Processing each item in a collection Waiting for a condition to change Counting a specific number of times Input validation loops Using <code>enumerate()</code> or <code>zip()</code> Implementing retry logic The loop should end naturally You need <code>while True</code> with <code>break</code>"},{"location":"basics/control_structures/while_loops/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Basic while <code>while condition:</code> \u2014 loops while condition is True while True Common pattern with explicit <code>break</code> Input validation Loop with <code>continue</code> (retry) and <code>break</code> (success) Sentinel values Special value that signals end of input Retry with limits Add a counter to prevent infinite attempts else clause Runs if loop completes without <code>break</code> Infinite by design Some programs (servers, games) intentionally run forever"},{"location":"basics/data_structures/dictionaries/","title":"Dictionaries","text":"<p>Dictionaries are one of the most important data structures in Python \u2014 and they're everywhere. \ud83d\udcd6 Even when you don't see them directly, they're often working behind the scenes, quietly holding things together.</p> <p>For instance, while a string like <code>\"hello\"</code> isn\u2019t itself a dictionary, many Python objects (including strings) use internal dictionaries to store attributes and metadata. And when you assign <code>a = \"my_name\"</code>, you're creating a name (<code>a</code>) that points to a string object \u2014 which, like most Python objects, has a dictionary of attributes under the hood.</p> <p>The real magic of dictionaries is association. Linking keys to values (<code>key: value</code>) creates fast and flexible lookups. Want to find a user\u2019s email by their username? Dictionary. Want to count how many times something appears? Dictionary.</p> <p>If you\u2019ve used other programming languages, you might have heard these referred to as associative arrays, hash maps, or just maps. It\u2019s the same core idea: match a key to a value. Think of it like an old-school phone book \u2014 you know the name, and the dictionary gives you the number.</p> <p>Dictionaries are a much less compute-intensive way to associate two values than say, keeping those values in two lists (where the order is guaranteed). In fact, the lookup speed of a dictionary is not affected by its size! \u26a1 That's some serious performance.</p> Tip <p>Every key in a dictionary must be unique and hashable.  In practical terms, this means you can't use a mutable object as keys - so you can't use a <code>list</code> or a <code>dict</code> as as a key in a dictionary. This will throw a <code>TypeError</code> exception. Mutable objects can be assigned as values. For example, trying to assign the list <code>engine_parts</code> with <code>dream_car['engine_parts'] = 563</code>throws an error:</p> <pre><code>Traceback (most recent call last):\nFile \"/home/brad/Documents/exploring_python/basics/data_structures/dictionaries.py\", line 17, in &lt;module&gt;\n    dream_car[engine_parts] = 563\n    ~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'\n</code></pre> <p>The data type of a dictionary in Python is <code>dict</code>, and they're iterable, even though they're not a sequence type like a <code>list</code> or <code>set</code>. In lists, you can insert a value at a specific index position in the sequence. With dictionaries, position is determined by insertion order\u2014new items are always appended to the end. When iterating over a dictionary (see below), iteration will always happen in insertion order. This isn't an index, but the natural order of dictionaries.</p> Info <p>Prior to Python <code>v3.6</code>, there was no guaranteed order of dictionaries at all. As of <code>v3.6</code>, this changed, and dictionaries are guaranteed to iterate over the insertion order.</p>"},{"location":"basics/data_structures/dictionaries/#creating-a-dictionary","title":"Creating a Dictionary","text":"<p>Dictionaries can be declared with:</p> Creating a Dictionary<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400,\n}\n</code></pre> <p>To retrieve a value, use square brackets <code>[]</code> and supply a key (not an index like a list):</p> <pre><code>print(f\"Dream car: {dream_car['year']} {dream_car['make']} {dream_car['model']}\")\n</code></pre> <p>Would return:</p> <pre><code>Dream car: 1971 Ford Pinto\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#inserting-or-changing-a-value","title":"Inserting or Changing a Value","text":"<p>You can insert or update a key/value pair using the same square bracket syntax with an assignment:</p> Inserting and Updating Key/Value Pairs<pre><code>dream_car['make'] = \"Ferrari\"\ndream_car['model'] = \"365 GTS/4 Daytona\"\ndream_car['colour'] = \"Rosso Chiaro\"\nprint(f\"Dream car: {dream_car['year']} {dream_car['make']} {dream_car['model']} of the colour {dream_car['colour']}.\")\n</code></pre> <p>This would output:</p> <pre><code>Dream car: 1971 Ferrari 365 GTS/4 Daytona of the colour Rosso Chiaro.\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#deleting-a-keyvalue-pair","title":"Deleting a Key/Value Pair","text":"<p>Removing an entry is as easy as using the <code>del</code> keyword:</p> Deleting a Key/Value Pair<pre><code>del dream_car['colour']\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#avoiding-keyerror-with-get","title":"Avoiding <code>KeyError</code> with <code>get()</code>","text":"<p>Attempting to read or delete a key that doesn\u2019t exist will raise a <code>KeyError</code> exception. For example, attempting to retrieve <code>dream_car['engine']</code> would result in:</p> <pre><code>Traceback (most recent call last):\nFile \"exploring_python/basics/data_structures/dictionaries.py\", line 19, in &lt;module&gt;\n    dream_car['engine']\n    ~~~~~~~~~^^^^^^^^^^\nKeyError: 'engine'\n</code></pre> <p>The <code>dict.get()</code> method tries to find a key in a dictionary and will not raise an error if that key doesn't exist. Even better, you can assign a default value to return if the key is missing (the default is <code>None</code>). So, if you search for a key and it isn't present, the default value will be returned:</p> Creating a Dictionary<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400,\n}\n\nprint(dream_car.get('engine', 'V8'))\n</code></pre> <p>Returns:</p> <pre><code>V8\n</code></pre> Tip <p>Note that the key/value pair <code>engine: V8</code> isn't inserted into the dictionary. Instead, this one-time value is returned to avoid throwing a <code>KeyError</code>.</p>"},{"location":"basics/data_structures/dictionaries/#clearing-a-dictionary","title":"Clearing a Dictionary","text":"<p>If the data in a dictionary is no longer valuable, but you'd like to keep the same dictionary object, use the <code>clear()</code> method to empty a dictionary without changing the id.</p> Clear a Dictionary but Keep the Object<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400\n}\n\nprint(f\"Dream Car Object ID: {id(dream_car)}\")\ndream_car.clear()\nprint(f\"Dream Car after clear: {dream_car}\")\nprint(f\"Dream Car Object ID after clear: {id(dream_car)}\")\n</code></pre> <p>Results in:</p> <pre><code>Dream Car Object ID: 140457216790016\nDream Car after clear: {}\nDream Car Object ID after clear: 140457216790016\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#merging-dictionaries","title":"Merging Dictionaries","text":"<p>Dictionaries often store related data, so merging them is a common task. To do this, use the <code>update()</code> method. When you call <code>update()</code>, the dictionary you pass in will merge with the original dictionary: it will update any values with the same key and add any key/value pairs that did not exist in the original dictionary.</p> Merging Dictionaries<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400\n}\n\ndream_car_engine = {\n    \"engine\": \"V8\",\n    \"horsepower\": 440,\n    \"cylinders\": 8\n}\n\ndream_car.update(dream_car_engine) # (1)\nprint(f\"Dream Car: {dream_car}\")\nprint(f\"Dream Car Engine: {dream_car_engine}\")\n</code></pre> <ol> <li>The <code>update()</code> method is also available, with similar functionality, in    <code>sets</code></li> </ol> <p>Would output:</p> <pre><code>Dream Car: {'model': 'Pinto', 'make': 'Ford', 'year': 1971, 'mileage': 400, 'engine': 'V8', 'horsepower': 440, 'cylinders': 8}\nDream Car Engine: {'engine': 'V8', 'horsepower': 440, 'cylinders': 8}\n</code></pre> <p>Note how <code>dream_car_engine</code> was not modified by the <code>update()</code> function, only <code>dream_car</code>.</p>"},{"location":"basics/data_structures/dictionaries/#merge-operator-python-39","title":"Merge Operator (Python 3.9+)","text":"<p>Python 3.9 introduced the <code>|</code> operator for merging dictionaries:</p> Merge Operator<pre><code>defaults = {\"theme\": \"dark\", \"font_size\": 12, \"language\": \"en\"}\nuser_prefs = {\"font_size\": 14, \"sidebar\": True}\n\n# Merge (user_prefs values win on conflict)\ncombined = defaults | user_prefs\nprint(combined)\n# {'theme': 'dark', 'font_size': 14, 'language': 'en', 'sidebar': True}\n\n# Update in place\ndefaults |= user_prefs\nprint(defaults)\n# {'theme': 'dark', 'font_size': 14, 'language': 'en', 'sidebar': True}\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#the-setdefault-method","title":"The setdefault() Method","text":"<p><code>setdefault()</code> gets a value if the key exists, or sets it to a default if it doesn't:</p> setdefault()<pre><code>inventory = {\"apples\": 5, \"bananas\": 3}\n\n# Key exists \u2014 just returns the value\ncount = inventory.setdefault(\"apples\", 0)\nprint(count)       # 5\nprint(inventory)   # {'apples': 5, 'bananas': 3}\n\n# Key doesn't exist \u2014 sets it and returns the default\ncount = inventory.setdefault(\"oranges\", 0)\nprint(count)       # 0\nprint(inventory)   # {'apples': 5, 'bananas': 3, 'oranges': 0}\n</code></pre> <p>This is particularly useful for building up collections:</p> Building Lists in a Dict<pre><code># Grouping items by category\nitems = [(\"fruit\", \"apple\"), (\"veggie\", \"carrot\"), (\"fruit\", \"banana\")]\n\ngrouped = {}\nfor category, item in items:\n    grouped.setdefault(category, []).append(item)\n\nprint(grouped)\n# {'fruit': ['apple', 'banana'], 'veggie': ['carrot']}\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#dictionary-comprehensions","title":"Dictionary Comprehensions","text":"<p>Just like list comprehensions, you can create dictionaries with a concise syntax:</p> Dict Comprehensions<pre><code># Basic: {key_expr: value_expr for item in iterable}\nsquares = {x: x**2 for x in range(6)}\nprint(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# With filtering\neven_squares = {x: x**2 for x in range(10) if x % 2 == 0}\nprint(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n\n# Transform existing dict\nprices = {\"apple\": 0.50, \"banana\": 0.25, \"orange\": 0.75}\ndoubled = {fruit: price * 2 for fruit, price in prices.items()}\nprint(doubled)  # {'apple': 1.0, 'banana': 0.5, 'orange': 1.5}\n\n# Swap keys and values\nflipped = {v: k for k, v in prices.items()}\nprint(flipped)  # {0.5: 'apple', 0.25: 'banana', 0.75: 'orange'}\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#practical-dict-comprehension-patterns","title":"Practical Dict Comprehension Patterns","text":"Common Patterns<pre><code># Create lookup from list\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nname_lengths = {name: len(name) for name in names}\nprint(name_lengths)  # {'Alice': 5, 'Bob': 3, 'Charlie': 7}\n\n# Filter a dictionary\nscores = {\"Alice\": 85, \"Bob\": 92, \"Charlie\": 78, \"Diana\": 95}\npassing = {name: score for name, score in scores.items() if score &gt;= 80}\nprint(passing)  # {'Alice': 85, 'Bob': 92, 'Diana': 95}\n\n# Convert keys to uppercase\nupper_scores = {name.upper(): score for name, score in scores.items()}\nprint(upper_scores)  # {'ALICE': 85, 'BOB': 92, 'CHARLIE': 78, 'DIANA': 95}\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#defaultdict-dictionaries-with-default-values","title":"defaultdict: Dictionaries with Default Values","text":"<p>The <code>defaultdict</code> from the <code>collections</code> module automatically creates missing keys with a default value. No more <code>KeyError</code>! \ud83c\udf89</p> defaultdict Basics<pre><code>from collections import defaultdict\n\n# Regular dict raises KeyError\nregular = {}\n# regular[\"missing\"] += 1  # KeyError!\n\n# defaultdict provides a default\ncounter = defaultdict(int)  # int() returns 0\ncounter[\"apples\"] += 1\ncounter[\"apples\"] += 1\ncounter[\"bananas\"] += 1\nprint(dict(counter))  # {'apples': 2, 'bananas': 1}\n\n# defaultdict with list\ngroups = defaultdict(list)\ngroups[\"fruit\"].append(\"apple\")\ngroups[\"fruit\"].append(\"banana\")\ngroups[\"veggie\"].append(\"carrot\")\nprint(dict(groups))  # {'fruit': ['apple', 'banana'], 'veggie': ['carrot']}\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#common-defaultdict-factories","title":"Common defaultdict Factories","text":"defaultdict Factories<pre><code>from collections import defaultdict\n\n# int \u2014 for counting\nword_counts = defaultdict(int)\n\n# list \u2014 for grouping\ngrouped_items = defaultdict(list)\n\n# set \u2014 for unique grouping\nunique_tags = defaultdict(set)\n\n# Custom default\ndefault_score = defaultdict(lambda: 100)\nprint(default_score[\"new_player\"])  # 100\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#counter-counting-made-easy","title":"Counter: Counting Made Easy","text":"<p><code>Counter</code> is a specialized dict for counting hashable objects. Perfect for answering questions like \"How many times did someone order pepperoni?\" (Spoiler: a lot. But at least it wasn't on cheap pizza.)</p> Counter Basics<pre><code>from collections import Counter\n\n# Count from an iterable\nword = \"mississippi\"\nletter_counts = Counter(word)\nprint(letter_counts)\n# Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})\n\n# Count from a list\nvotes = [\"alice\", \"bob\", \"alice\", \"charlie\", \"alice\", \"bob\"]\nresults = Counter(votes)\nprint(results)\n# Counter({'alice': 3, 'bob': 2, 'charlie': 1})\n\n# Most common items\nprint(results.most_common(2))  # [('alice', 3), ('bob', 2)]\n\n# Access counts like a dict\nprint(results[\"alice\"])  # 3\nprint(results[\"nobody\"])  # 0 (not KeyError!)\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#counter-operations","title":"Counter Operations","text":"Counter Operations<pre><code>from collections import Counter\n\nc1 = Counter(a=3, b=1)\nc2 = Counter(a=1, b=2)\n\n# Add counts\nprint(c1 + c2)  # Counter({'a': 4, 'b': 3})\n\n# Subtract counts\nprint(c1 - c2)  # Counter({'a': 2})\n\n# Intersection (minimum counts)\nprint(c1 &amp; c2)  # Counter({'a': 1, 'b': 1})\n\n# Union (maximum counts)\nprint(c1 | c2)  # Counter({'a': 3, 'b': 2})\n\n# Total count\nprint(c1.total())  # 4 (Python 3.10+)\n</code></pre>"},{"location":"basics/data_structures/dictionaries/#iterating-over-dictionaries","title":"Iterating Over Dictionaries","text":"<p>Three ways to iterate, depending on what you need:</p> Dictionary Iteration<pre><code>person = {\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"}\n\n# Iterate over keys (default)\nfor key in person:\n    print(key)\n\n# Explicit keys\nfor key in person.keys():\n    print(key)\n\n# Iterate over values\nfor value in person.values():\n    print(value)\n\n# Iterate over key-value pairs (most common!)\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n</code></pre> <p>items() is Your Friend</p> <p>When you need both key and value, always use <code>items()</code>. It's cleaner than <code>for key in dict: value = dict[key]</code>.</p>"},{"location":"basics/data_structures/dictionaries/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Creating <code>{\"key\": value}</code> or <code>dict()</code> Accessing <code>dict[key]</code> or <code>dict.get(key, default)</code> Adding/Updating <code>dict[key] = value</code> Deleting <code>del dict[key]</code> or <code>dict.pop(key)</code> Merging <code>dict.update(other)</code> or <code>dict1 \\| dict2</code> (3.9+) setdefault() Get or set a default in one step Comprehensions <code>{k: v for k, v in items}</code> defaultdict Auto-creates missing keys with a factory Counter Specialized dict for counting Iteration <code>keys()</code>, <code>values()</code>, <code>items()</code> Order Insertion order preserved (Python 3.7+)"},{"location":"basics/data_structures/lists/","title":"Lists","text":"<p>You need to track a shopping list. Process log file entries. Store user responses. Manage a collection of database records. What do all these tasks have in common?</p> <p>They require storing multiple values in a single, flexible data structure. In Python, that structure is the list.</p> <p>Lists are ordered, mutable sequences\u2014arguably Python's most versatile data structure. You'll use them constantly, from small scripts to large applications. Understanding lists deeply transforms what you can build.</p>"},{"location":"basics/data_structures/lists/#what-is-a-list","title":"What is a List?","text":"<p>A list is an ordered collection of items, defined with square brackets:</p> Creating Lists<pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]  # (1)!\nnumbers = [1, 2, 3, 4, 5]\nmixed = [\"Alice\", 30, 3.14, True]  # (2)!\nempty = []  # (3)!\n</code></pre> <ol> <li>Lists are created with square brackets <code>[...]</code> and items separated by commas</li> <li>Lists can contain different types\u2014strings, numbers, booleans, even other lists</li> <li>Empty lists are valid and common as starting points</li> </ol> <p>Lists maintain insertion order and allow duplicates:</p> Order and Duplicates<pre><code>colors = [\"red\", \"blue\", \"red\", \"green\"]  # (1)!\nprint(colors[0])  # \"red\" - first item\nprint(colors[2])  # \"red\" - third item (duplicate)\n</code></pre> <ol> <li>Lists preserve order and permit duplicate values</li> </ol>"},{"location":"basics/data_structures/lists/#why-lists-matter","title":"Why Lists Matter","text":"<p>Lists solve a fundamental programming problem: managing collections of related data. This reflects core computational thinking\u2014abstracting individual items into structured collections you can process systematically.</p> <ul> <li>User input: Store multiple form entries, search queries, uploaded files</li> <li>Data processing: Read CSV rows, parse log lines, accumulate results</li> <li>Game development: Track inventory items, enemy positions, player scores</li> <li>Web scraping: Collect links, extract product details, gather search results</li> <li>APIs: Process JSON arrays, build request parameters, aggregate responses</li> </ul> <p>Without lists (or similar structures), you'd need separate variables for every value. Three users? <code>user1</code>, <code>user2</code>, <code>user3</code>. Ten users? This doesn't scale. Lists do.</p>"},{"location":"basics/data_structures/lists/#accessing-list-elements","title":"Accessing List Elements","text":"<p>Display the first search result. Get the last log entry. Process every third item. Skip the header row in a CSV file. All require accessing specific positions in a list.</p> <p>Lists use zero-based indexing:</p> List Indexing<pre><code>languages = [\"Python\", \"JavaScript\", \"Go\", \"Rust\"]\nprint(languages[0])   # (1)!\nprint(languages[2])\nprint(languages[-1])  # (2)!\nprint(languages[-2])\nprint(len(languages)) # (3)!\n</code></pre> <ol> <li>Returns <code>\"Python\"</code> - Python uses zero-based indexing so the first element is at index 0</li> <li>Returns <code>\"Rust\"</code> - negative indices count backward from the end: -1 is last, -2 is second-to-last</li> <li>Returns <code>4</code> - <code>len()</code> returns the total number of elements in the list</li> </ol> <p>Attempting to access an invalid index raises an <code>IndexError</code>:</p> Index Out of Range<pre><code>fruits = [\"apple\", \"banana\"]\nprint(fruits[0])      # (1)!\nprint(fruits[1])      # (2)!\n# print(fruits[5])    # Would raise IndexError!\n</code></pre> <ol> <li>Returns <code>\"apple\"</code> - valid index (list has indices 0 and 1)</li> <li>Returns <code>\"banana\"</code> - the last valid index</li> </ol> <p>Accessing <code>fruits[5]</code> would raise <code>IndexError: list index out of range</code> since only indices 0 and 1 exist.</p>"},{"location":"basics/data_structures/lists/#list-mutability-changing-lists","title":"List Mutability: Changing Lists","text":"<p>Users add items to shopping carts. You filter invalid entries from data. Tasks get completed and removed. Collections grow and shrink as programs run. This is why lists are mutable\u2014they reflect dynamic, changing data.</p> <p>Unlike strings, lists are mutable\u2014they can be modified after creation:</p>"},{"location":"basics/data_structures/lists/#adding-elements","title":"Adding Elements","text":"<p>Appending - User adds item to shopping cart. You're accumulating search results. Building a list of errors as you validate data:</p> Appending to Lists<pre><code>tasks = [\"email\", \"code review\"]\ntasks.append(\"meeting\")  # (1)!\nprint(tasks)  # [\"email\", \"code review\", \"meeting\"]\n</code></pre> <ol> <li><code>.append()</code> adds an element to the end\u2014the most common way to grow lists</li> </ol> <p>Inserting - Adding a high-priority task at the top of a todo list. Inserting a header row into CSV data. Maintaining sorted order while building a list:</p> Inserting at Specific Positions<pre><code>numbers = [1, 2, 4]\nnumbers.insert(2, 3)  # (1)!\nprint(numbers)  # [1, 2, 3, 4]\n</code></pre> <ol> <li><code>.insert(index, value)</code> adds an element at the specified position</li> </ol> <p>Extending - Merging results from multiple API calls. Combining data from different sources. Loading additional items as user scrolls (pagination):</p> Extending with Multiple Items<pre><code>list1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist1.extend(list2)  # (1)!\nprint(list1)  # [1, 2, 3, 4, 5, 6]\n</code></pre> <ol> <li><code>.extend()</code> adds all items from another list\u2014different from <code>.append()</code> which adds the entire list as a single element</li> </ol>"},{"location":"basics/data_structures/lists/#removing-elements","title":"Removing Elements","text":"<p>User removes item from cart. Filter out invalid entries during data cleaning. Task completed and needs removal from active list:</p> Removing Items<pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"banana\"]\nfruits.remove(\"banana\")  # (1)!\nprint(fruits)  # [\"apple\", \"cherry\", \"banana\"]\n\npopped = fruits.pop()  # (2)!\nprint(popped)  # \"banana\"\nprint(fruits)  # [\"apple\", \"cherry\"]\n\nfirst = fruits.pop(0)  # (3)!\nprint(first)  # \"apple\"\nprint(fruits)  # [\"cherry\"]\n</code></pre> <ol> <li><code>.remove(value)</code> removes the first occurrence of the value</li> <li><code>.pop()</code> removes and returns the last element</li> <li><code>.pop(index)</code> removes and returns the element at the specified index</li> </ol> Deleting by Index<pre><code>numbers = [10, 20, 30, 40]\ndel numbers[1]  # (1)!\nprint(numbers)  # [10, 30, 40]\n</code></pre> <ol> <li><code>del</code> removes an element by index\u2014useful but doesn't return the value</li> </ol>"},{"location":"basics/data_structures/lists/#modifying-elements","title":"Modifying Elements","text":"<p>Update a score after recalculation. Correct an error in imported data. Apply a transformation to a specific position:</p> Changing Values<pre><code>scores = [85, 90, 78]\nscores[1] = 95  # (1)!\nprint(scores)  # [85, 95, 78]\n</code></pre> <ol> <li>Assign to an index to change the value at that position</li> </ol>"},{"location":"basics/data_structures/lists/#sorting-and-reversing","title":"Sorting and Reversing","text":"<p>Leaderboards rank scores. Product listings sort by price. Search results order by relevance. Log entries display newest first. Sorting and reversing are essential for presenting data meaningfully:</p> Sorting Lists<pre><code>numbers = [3, 1, 4, 1, 5, 9]\nnumbers.sort()  # (1)!\nprint(numbers)  # [1, 1, 3, 4, 5, 9]\n\nwords = [\"zebra\", \"apple\", \"banana\"]\nwords.sort(reverse=True)  # (2)!\nprint(words)  # [\"zebra\", \"banana\", \"apple\"]\n</code></pre> <ol> <li><code>.sort()</code> sorts the list in place\u2014modifies the original list</li> <li><code>reverse=True</code> sorts in descending order</li> </ol> Sorted Without Modifying<pre><code>original = [3, 1, 4]\nsorted_copy = sorted(original)  # (1)!\nprint(original)      # [3, 1, 4] - unchanged\nprint(sorted_copy)   # [1, 3, 4] - new sorted list\n</code></pre> <ol> <li><code>sorted()</code> returns a new sorted list\u2014original remains unchanged</li> </ol> Reversing Lists<pre><code>items = [1, 2, 3, 4]\nitems.reverse()  # (1)!\nprint(items)  # [4, 3, 2, 1]\n</code></pre> <ol> <li><code>.reverse()</code> reverses the list in place</li> </ol>"},{"location":"basics/data_structures/lists/#checking-membership","title":"Checking Membership","text":"<p>Is this username already taken? Does the shopping cart contain this item? Has this email been processed? Membership testing answers these questions efficiently:</p> Testing Membership<pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"apple\" in fruits)     # (1)!\nprint(\"grape\" in fruits)\nprint(\"grape\" not in fruits) # (2)!\n</code></pre> <ol> <li>Returns <code>True</code> - the <code>in</code> operator checks if an element exists in the list</li> <li>Returns <code>True</code> - the <code>not in</code> operator checks if an element doesn't exist</li> </ol>"},{"location":"basics/data_structures/lists/#list-slicing","title":"List Slicing","text":"<p>Show the top 10 search results. Process data in batches of 100. Get the last 5 log entries. Display page 3 of results (items 20-30). Slicing extracts exactly the portion you need:</p> <p>Slicing extracts portions of a list:</p> Slicing Lists<pre><code>numbers = [0, 1, 2, 3, 4, 5]\nprint(numbers[1:4])   # (1)!\nprint(numbers[:3])    # (2)!\nprint(numbers[3:])\nprint(numbers[-2:])\nprint(numbers[::2])   # (3)!\n</code></pre> <ol> <li>Returns <code>[1, 2, 3]</code> - slicing uses <code>[start:end]</code> which includes start but excludes end</li> <li>Returns <code>[0, 1, 2]</code> - omitting start slices from the beginning</li> <li>Returns <code>[0, 2, 4]</code> - the third parameter is step: <code>[start:end:step]</code></li> </ol> <p>Slices create new lists\u2014they don't modify the original:</p> Slicing Creates Copies<pre><code>original = [1, 2, 3, 4]\nsubset = original[1:3]  # (1)!\nsubset[0] = 99\nprint(original)  # [1, 2, 3, 4] - unchanged\nprint(subset)    # [99, 3] - modified\n</code></pre> <ol> <li>Slices are shallow copies\u2014modifying the slice doesn't affect the original</li> </ol>"},{"location":"basics/data_structures/lists/#common-patterns","title":"Common Patterns","text":""},{"location":"basics/data_structures/lists/#iterating-over-lists","title":"Iterating Over Lists","text":"<p>Process each email in an inbox. Validate every form field. Send notifications to all subscribers:</p> Looping Through Lists<pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits:  # (1)!\n    print(f\"I like {fruit}\")\n</code></pre> <ol> <li>The most Pythonic way to iterate\u2014directly over elements, not indices (see For Loops)</li> </ol>"},{"location":"basics/data_structures/lists/#finding-elements","title":"Finding Elements","text":"<p>Locate where a specific user appears in a list. Count how many times an error occurred. Find the position of a selected item:</p> Finding Index of Element<pre><code>colors = [\"red\", \"green\", \"blue\", \"green\"]\nindex = colors.index(\"green\")  # (1)!\nprint(index)  # 1 - first occurrence\n\ncount = colors.count(\"green\")  # (2)!\nprint(count)  # 2 - number of occurrences\n</code></pre> <ol> <li><code>.index(value)</code> returns the index of the first occurrence (raises ValueError if not found)</li> <li><code>.count(value)</code> returns how many times the value appears</li> </ol>"},{"location":"basics/data_structures/lists/#copying-lists","title":"Copying Lists","text":"<p>Preserve original data before modifications. Create a backup before filtering. Pass a copy to a function that might modify it:</p> Copying Lists<pre><code>original = [1, 2, 3]\nshallow_copy = original.copy()  # (1)!\nanother_copy = original[:]      # (2)!\n\nshallow_copy.append(4)\nprint(original)      # [1, 2, 3] - unchanged\nprint(shallow_copy)  # [1, 2, 3, 4]\n</code></pre> <ol> <li><code>.copy()</code> creates a shallow copy\u2014explicit and readable</li> <li><code>[:]</code> (slice everything) also creates a copy\u2014common idiom</li> </ol>"},{"location":"basics/data_structures/lists/#lists-vs-tuples","title":"Lists vs. Tuples","text":"<p>Python has another sequence type called tuples, which are immutable:</p> Lists vs Tuples<pre><code>my_list = [1, 2, 3]   # Mutable - can change\nmy_tuple = (1, 2, 3)  # Immutable - cannot change (1)!\n\nmy_list[0] = 99   # \u2713 Allowed\n# my_tuple[0] = 99  # \u2717 TypeError!\n</code></pre> <ol> <li>Tuples use parentheses <code>(...)</code> instead of brackets <code>[...]</code></li> </ol> <p>Use lists when you need a collection that can grow, shrink, or change. Use tuples for fixed collections. (See the Tuples article for details.)</p>"},{"location":"basics/data_structures/lists/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Indexing <p>Given <code>names = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"]</code>, what does <code>names[-2]</code> return?</p> Answer <p>It returns <code>\"Charlie\"</code> (the second-to-last element). Negative indices count from the end: <code>-1</code> is last, <code>-2</code> is second-to-last, etc.</p> Practice Problem 2: Mutability <p>What's the difference between <code>.append([1, 2])</code> and <code>.extend([1, 2])</code> when called on a list?</p> Answer <pre><code>list1 = [0]\nlist1.append([1, 2])\nprint(list1)  # [0, [1, 2]] - adds the entire list as a single element\n\nlist2 = [0]\nlist2.extend([1, 2])\nprint(list2)  # [0, 1, 2] - adds each element individually\n</code></pre> <p><code>.append()</code> adds its argument as a single element. <code>.extend()</code> adds each element from an iterable.</p> Practice Problem 3: Slicing <p>How would you get the last 3 elements of a list without knowing its length?</p> Answer <pre><code>numbers = [1, 2, 3, 4, 5, 6, 7]\nlast_three = numbers[-3:]\nprint(last_three)  # [5, 6, 7]\n</code></pre> <p><code>[-3:]</code> means \"from third-from-end to the end\"\u2014works regardless of list length.</p> Practice Problem 4: Removing Elements <p>What's the difference between <code>.remove(value)</code> and <code>.pop(index)</code>?</p> Answer <ul> <li><code>.remove(value)</code> finds and removes the first occurrence of a value (raises ValueError if not found)</li> <li><code>.pop(index)</code> removes and returns the element at a specific index (raises IndexError if invalid)</li> </ul> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nfruits.remove(\"banana\")  # Removes by value\nprint(fruits)  # [\"apple\", \"cherry\"]\n\nnumbers = [10, 20, 30]\nremoved = numbers.pop(1)  # Removes by index, returns value\nprint(removed)  # 20\nprint(numbers)  # [10, 30]\n</code></pre>"},{"location":"basics/data_structures/lists/#key-takeaways","title":"Key Takeaways","text":"Concept What It Means List Ordered, mutable collection of items Mutability Lists can be modified after creation (unlike strings or tuples) Indexing Access elements by position (zero-based, negative from end) Slicing Extract portions: <code>[start:end:step]</code> <code>.append()</code> Add single element to end <code>.extend()</code> Add multiple elements from iterable <code>.remove()</code> Remove first occurrence of value <code>.pop()</code> Remove and return element by index"},{"location":"basics/data_structures/lists/#further-reading","title":"Further Reading","text":"<ul> <li>Python List Documentation - Official tutorial on lists</li> <li>Time Complexity of List Operations - Performance characteristics</li> <li>List Comprehensions - Elegant way to create lists</li> <li>Sorting HOW TO - Advanced sorting techniques</li> </ul> <p>Lists are the workhorse of Python data structures. They're flexible enough for quick scripts and powerful enough for production systems. Learn to use them fluently\u2014appending, slicing, sorting, iterating\u2014and you'll handle most data management tasks with ease.</p> <p>Arrays in C require fixed sizes. JavaScript arrays have quirky behavior. Python lists just work, with intuitive methods and predictable semantics. That's part of what makes Python a joy to use.</p>"},{"location":"basics/data_structures/membership_testing/","title":"Membership Testing","text":"<p>When working with data structures, one of the most common questions is \"Does this value exist in this data structure?\" \ud83d\udd0d Python comes to the rescue here with two operators: <code>in</code> and <code>not in</code>.</p>"},{"location":"basics/data_structures/membership_testing/#testing-membership-in-sequences","title":"Testing Membership in Sequences","text":"<p>Recall that the sequence types in Python are <code>list</code> and <code>tuples</code>. While they can contain any data type, the order of the elements is guaranteed.</p> <p>Testing membership using the <code>in</code> and <code>not in</code> operators combined with an <code>if</code> statement returns a truthy value (<code>boolean</code>) to indicate membership:</p> Testing Membership in a List<pre><code>fav_books = ['mastery', 'the signal and the noise', 'the organized mind']\n\nif 'mastery' in fav_books:\n    print(\"One of your favourites!\")\nelse:\n    print(\"Maybe something new to consider?\")\n</code></pre> <p>Returns:</p> <pre><code>One of your favourites!\n</code></pre> <p>Using <code>not in</code> works the opposite:</p> Negative Testing Membership in a List<pre><code>fav_books = ['mastery', 'the signal and the noise', 'the organized mind']\n\nif 'discipline is destiny' not in fav_books:\n    print(\"Have your read this one? Maybe you should!\")\nelse:\n    print(\"Ye ole` favourites once again!\")\n</code></pre> <p>Would result in:</p> <pre><code>Have your read this one? Maybe you should!\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#testing-membership-in-dictionaries","title":"Testing Membership in Dictionaries","text":"<p>Dictionaries (the <code>dict</code> data structure) present a little bit of a special case in testing membership, the caveat being you must remember that by default, the test runs against the key of the dictionary, not the entire key/value pair, nor against the value itself.</p> Testing Membership in Dictionary Keys<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400,\n}\n\nif 'year' in dream_car:\n    print(\"Good to know the year of your dream car!\")\nelse:\n    print(\"What year is your dream car?\")\n</code></pre> <p>Would output:</p> <pre><code>Good to know the year of your dream car!\n</code></pre> <p>If you'd like to test to see if a specific value is in a dictionary, remmember to use the <code>dict.values()</code> method:</p> Negative Testing Membership in Dictionary Values<pre><code>dream_car = {\n    \"model\": \"Pinto\",\n    \"make\": \"Ford\",\n    \"year\": 1971,\n    \"mileage\": 400,\n}\n\nif 'Pinto' not in dream_car.values():\n    print(\"Your dream car isn't a Pinto???!??\")\nelse:\n    print(\"Nothing quite as sweet as a lovely Pinto!\")\n</code></pre> <p>Which would return:</p> <pre><code>Nothing quite as sweet as a lovely Pinto!\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#testing-membership-in-strings","title":"Testing Membership in Strings","text":"<p>Strings support <code>in</code> for substring checking:</p> Substring Testing<pre><code>message = \"Hello, World!\"\n\nprint(\"World\" in message)     # True\nprint(\"world\" in message)     # False \u2014 case-sensitive!\nprint(\"Hello\" in message)     # True\nprint(\"xyz\" not in message)   # True\n\n# Case-insensitive check\nprint(\"world\" in message.lower())  # True\n</code></pre> <p>This is more readable than using <code>find()</code> or <code>index()</code>:</p> in vs find()<pre><code>text = \"The quick brown fox\"\n\n# Preferred \u2014 clean and readable\nif \"fox\" in text:\n    print(\"Found it!\")\n\n# Works, but less Pythonic\nif text.find(\"fox\") != -1:\n    print(\"Found it!\")\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#performance-choosing-the-right-data-structure","title":"Performance: Choosing the Right Data Structure","text":"<p>Not all membership tests are created equal. The choice of data structure dramatically affects performance \u2014 like the difference between a hand-crafted espresso and that sad office drip coffee. Both contain caffeine, but one sparks joy. \u26a1</p> Data Structure <code>in</code> Performance Notes <code>list</code> O(n) \u2014 slow Checks each element sequentially <code>tuple</code> O(n) \u2014 slow Same as list <code>set</code> O(1) \u2014 fast! Hash-based lookup <code>frozenset</code> O(1) \u2014 fast! Same as set <code>dict</code> keys O(1) \u2014 fast! Hash-based lookup <code>str</code> O(n) \u2014 depends Substring search"},{"location":"basics/data_structures/membership_testing/#the-practical-impact","title":"The Practical Impact","text":"Performance Comparison<pre><code>import time\n\n# Create test data\nlarge_list = list(range(1_000_000))\nlarge_set = set(range(1_000_000))\n\n# What we're looking for (worst case \u2014 at the end or missing)\ntarget = 999_999\n\n# List search \u2014 slow!\nstart = time.time()\n_ = target in large_list\nprint(f\"List: {time.time() - start:.6f} seconds\")\n\n# Set search \u2014 instant!\nstart = time.time()\n_ = target in large_set\nprint(f\"Set: {time.time() - start:.6f} seconds\")\n\n# Typical output:\n# List: 0.015000 seconds\n# Set: 0.000001 seconds\n</code></pre> <p>When to Convert to Set</p> <p>If you're checking membership multiple times against the same collection, convert to a set first:</p> <pre><code>valid_codes = [\"A1\", \"B2\", \"C3\", \"D4\", ...]  # Original data\nvalid_set = set(valid_codes)  # One-time conversion\n\n# Now all lookups are O(1)\nfor code in user_inputs:\n    if code in valid_set:\n        process(code)\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#the-any-and-all-functions","title":"The <code>any()</code> and <code>all()</code> Functions","text":"<p>These built-in functions supercharge membership testing when you need to check multiple conditions.</p>"},{"location":"basics/data_structures/membership_testing/#any-at-least-one-true","title":"<code>any()</code> \u2014 At Least One True","text":"<p>Returns <code>True</code> if any element is truthy (or if any condition is met):</p> any() Examples<pre><code># Basic usage\nprint(any([False, False, True]))   # True\nprint(any([False, False, False]))  # False\nprint(any([]))                     # False (empty = no True values)\n\n# With generator expression \u2014 more common!\nnumbers = [1, 3, 5, 7, 8, 9]\nhas_even = any(n % 2 == 0 for n in numbers)\nprint(has_even)  # True (8 is even)\n\n# Check if any item exists in a collection\nsearch_terms = [\"error\", \"warning\", \"critical\"]\nlog_message = \"Warning: disk space low\"\n\nif any(term in log_message.lower() for term in search_terms):\n    print(\"Alert triggered!\")\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#all-every-one-true","title":"<code>all()</code> \u2014 Every One True","text":"<p>Returns <code>True</code> only if all elements are truthy:</p> all() Examples<pre><code># Basic usage\nprint(all([True, True, True]))   # True\nprint(all([True, False, True]))  # False\nprint(all([]))                   # True (vacuous truth!)\n\n# Check if all values pass a condition\nages = [25, 30, 18, 42]\nall_adults = all(age &gt;= 18 for age in ages)\nprint(all_adults)  # True\n\n# Validate all required fields\nuser = {\"name\": \"Alice\", \"email\": \"alice@example.com\", \"age\": 30}\nrequired = [\"name\", \"email\"]\nis_valid = all(field in user for field in required)\nprint(is_valid)  # True\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>Both <code>any()</code> and <code>all()</code> short-circuit \u2014 they stop as soon as they know the answer:</p> Short-Circuit Behavior<pre><code>def check(n):\n    print(f\"Checking {n}\")\n    return n &gt; 5\n\n# any() stops at first True\nprint(any(check(n) for n in [1, 2, 6, 3, 4]))\n# Checking 1\n# Checking 2\n# Checking 6  \u2190 stops here!\n# True\n\n# all() stops at first False\nprint(all(check(n) for n in [6, 7, 3, 8, 9]))\n# Checking 6\n# Checking 7\n# Checking 3  \u2190 stops here!\n# False\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#common-patterns","title":"Common Patterns","text":"Practical any()/all() Patterns<pre><code># Check if file has any of these extensions\nfilename = \"report.pdf\"\nvalid_extensions = [\".pdf\", \".doc\", \".txt\"]\nis_valid = any(filename.endswith(ext) for ext in valid_extensions)\n\n# Check if all passwords meet requirements\npasswords = [\"Abc123!\", \"SecurePass1\", \"MyP@ss99\"]\nall_valid = all(\n    len(p) &gt;= 8 and any(c.isdigit() for c in p)\n    for p in passwords\n)\n\n# Check if any item in cart is out of stock\ncart = [{\"item\": \"widget\", \"stock\": 5}, {\"item\": \"gadget\", \"stock\": 0}]\nhas_out_of_stock = any(item[\"stock\"] == 0 for item in cart)\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#combining-membership-tests","title":"Combining Membership Tests","text":"Complex Membership Logic<pre><code># Check multiple memberships\nrequired_skills = {\"python\", \"sql\", \"git\"}\nnice_to_have = {\"docker\", \"kubernetes\", \"aws\"}\n\ncandidate_skills = {\"python\", \"sql\", \"git\", \"docker\", \"react\"}\n\n# Has all required?\nis_qualified = required_skills.issubset(candidate_skills)\nprint(is_qualified)  # True\n\n# Has any nice-to-have?\nhas_bonus = bool(nice_to_have &amp; candidate_skills)\nprint(has_bonus)  # True (has docker)\n\n# Count matches\nbonus_count = len(nice_to_have &amp; candidate_skills)\nprint(f\"Bonus skills: {bonus_count}\")  # Bonus skills: 1\n</code></pre>"},{"location":"basics/data_structures/membership_testing/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember <code>in</code> operator Works on lists, tuples, sets, dicts, strings <code>not in</code> Negation of membership test Dict membership Tests keys by default; use <code>.values()</code> for values String <code>in</code> Tests for substring, not character Performance Sets and dicts are O(1); lists/tuples are O(n) <code>any()</code> True if at least one element is truthy <code>all()</code> True only if every element is truthy Generator expressions Use with any()/all() for efficiency Short-circuit any()/all() stop early when answer is known"},{"location":"basics/data_structures/sets/","title":"Sets","text":"<p>In Python, Sets are a unique data type inspired by mathematical sets. \ud83c\udfb2 They are a collection of elements, like a <code>list</code> or <code>dict</code>, but there is no ordering of the elements, and there can be no duplicate elements. Think of it like a pizza order where everyone shouts their toppings \u2014 you end up with a unique list, no matter how many times someone yells \"pepperoni!\" (And please, no cheap pizza. Life's too short.)</p> <p>With that in mind, the main use of a <code>set</code> is to have a unique set of values, ideal when dealing with data prone to duplication, and then testing membership against that <code>set</code>.</p> <p>Like mathematical sets, Python sets support operations such as union, insertion, difference, and containment.</p> Rusty on mathematical sets?  Check out these videos! <p>General Set Theory</p> <p></p> <p>Union &amp; Intersection of Sets</p> <p></p> <p>Difference of Sets</p> <p></p> <p>Set Theory: Containment</p> <p></p> <p>Some programmers think of sets in Python as keyless dictionaries because a set must contain unique values, the order is not (yet) guaranteed, the elements are iterable, and they must be hashable.</p> \"Hashable? <p>A hashable object has a consistent hash value throughout its lifetime, and it can be compared for equality with other objects.</p> <p>A hash value, also known as a message digest or fingerprint, is a unique, fixed-length string produced by a hash function based on an input data.</p> <p>Sets are mutable objects in Python, similar to a<code>list</code>, which, somewhat ironcially, makes sets non-hashable (see note above) and therefore a <code>set</code> cannot be an element of a <code>set</code>. \ud83d\ude15</p> Frozenset <p>Check out the Python Standard Library type FrozenSet if you do require nested sets.</p>"},{"location":"basics/data_structures/sets/#creating-sets","title":"Creating Sets","text":"<p>In Python, a set is declared with curly braces (hence one of the comparison to keyless dictionaries):</p> Creating Sets<pre><code>colours = {\"red\",\"green\",\"blue\", \"orange\", \"red\", \"blue\", \"red\"}\nchess_pieces = set([\"king\",\"queen\",\"knight\",\"knight\", \"bishop\",\"bishop\",\n                    \"rook\", \"rook\", \"pawn\", \"pawn\", \"pawn\", \"pawn\", \"pawn\",\n                    \"pawn\", \"pawn\", \"pawn\"])\nprint(f\"Colours: {colours}\")\nprint(f\"Object type of colours variable: {type(colours)}\")\nprint(f\"Chess Pieces: {chess_pieces}\")\nprint(f\"Object type of chess_pieces variable: {type(chess_pieces)}\")\n</code></pre> <p>Outputs:</p> <pre><code>Colours: {'green', 'blue', 'red', 'orange'}\nObject type of colours variable: &lt;class 'set'&gt;\nChess Pieces: {'pawn', 'knight', 'rook', 'king', 'queen', 'bishop'}\nObject type of chess_pieces variable: &lt;class 'set'&gt;\n</code></pre> <p>Notice how even though duplicate values were passed in, all the elements of the <code>set</code> are unique and duplicates are ignored.</p> Tip <p>To create an empty <code>set</code>, use <code>variable = set()</code>, as <code>variable = {}</code> would create an empty <code>dict</code> object.</p> <p>Sets can use most of the familiar control structures in Python iterables such as <code>for</code> loops and membership testing. Other familiar functions for sequences also work such as <code>set.clear()</code>, <code>set.copy()</code>, <code>len(set)</code>, and so on.</p>"},{"location":"basics/data_structures/sets/#managing-set-elements","title":"Managing Set Elements","text":"<p>Because of their mathematical underpinnings, sets have functionality that other iterables do not.</p>"},{"location":"basics/data_structures/sets/#adding-elements","title":"Adding Elements","text":"<p>Unlike other iterables, there is no <code>append()</code> or <code>insert()</code> methods for sets as the order is not guaranteed.  Instead, sets use <code>add()</code>, and <code>update()</code>:</p> Adding Elements to Sets<pre><code>s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns1.add(4)\nprint(f\"Set 1 after adding 4: {s1}\")\ns1.update(s2) # (1)\nprint(f\"Set 1 after adding Set 2: {s1}\")\n</code></pre> <ol> <li>Adding two sets is referred to as the union of sets.  In this case, the union of <code>s1</code> and <code>s2</code> is assigned to <code>s1</code>.  See Merging Dictionaries for usage of <code>update()</code> method.</li> </ol> <p>Would output:</p> <pre><code>Set 1 after adding 4: {1, 2, 3, 4}\nSet 1 after adding Set 2: {1, 2, 3, 4, 5}\n</code></pre> <p>It is important to understand that adding the duplicate elements to a <code>set</code> will be ignored as the unique element already exists.</p>"},{"location":"basics/data_structures/sets/#removing-elements","title":"Removing Elements","text":"<p>Python offers two methods to remove elements from a set, <code>remove()</code>, and <code>discard()</code>.</p> Discarding Elements<pre><code>manager_nodes = {\"host1\", \"host7\", \"host12\"}\nprint(f\"Manager Nodes: {manager_nodes}\")\nmanager_nodes.discard(\"host7\")\nmanager_nodes.discard(\"host13\")  # (1)\nprint(f\"Manager Nodes after discarding: {manager_nodes}\")\n</code></pre> <ol> <li>This will not raise an error if \"host13\" is not present.  See tip below.</li> </ol> <p>Would output:</p> <pre><code>Manager Nodes: {'host1', 'host7', 'host12'}\nManager Nodes after discarding: {'host1', 'host12'}\n</code></pre> Remove with Caution! <p>Trying to use the <code>set.remove()</code> method on an element that doesn't exist in the <code>set</code> will result in a <code>KeyError</code> exception.  This may be useful in some situations, it is good to be aware of both options.</p>"},{"location":"basics/data_structures/sets/#comparing-sets","title":"Comparing Sets","text":""},{"location":"basics/data_structures/sets/#subsets-and-supersets","title":"Subsets and Supersets","text":"<p>It is possible to compare sets, returning a <code>boolean</code> value. When all the elements of one set are contained in a second set, the first set is called a subset of the second, and the second is called a superset of the first. Testing for subsets and supersets is common. Below is a table showing comparison operators for raw sets:</p> Statement True/False? Explanation <code>{2,3} &lt; {2,3,4}</code> \u2705 The first set is a subset of the second. <code>{2,3} &lt; {2,3}</code> \u274c The first set is not greater than the second. <code>{2,3} &lt;= {2,3,4}</code> \u2705 The second set is a superset of the first. <code>{2,3} &gt;= {2,3,4}</code> \u274c The first set is not a superset of the second. <p>Rather than having to depend on comparison operators, Python includes useful methods which evaluate set relationships - <code>issubset()</code> and <code>issuperset()</code>:</p> Testing Subsets and Supersets<pre><code>manager_nodes = {\"host1\", \"host7\", \"host12\"}\ncluster_nodes = {\"host1\", \"host2\", \"host3\", \"host4\", \"host5\", \"host6\", \\\n                 \"host7\", \"host8\", \"host9\", \"host10\", \"host11\", \"host12\"}\nprint(f\"Manager Nodes: {manager_nodes}\")\nprint(f\"Cluster Nodes: {cluster_nodes}\")\nprint(f\"Manager Nodes are present in Cluster Nodes: {manager_nodes.issubset(cluster_nodes)}\")\nprint(f\"Cluster Nodes contain all Manager Nodes: {cluster_nodes.issuperset(manager_nodes)}\")\n</code></pre> <p>Yields:</p> <pre><code>Manager Nodes: {'host7', 'host1', 'host12'}\nCluster Nodes: {'host3', 'host12', 'host5', 'host1', 'host2', 'host10', 'host7', 'host6', 'host8', 'host4', 'host9', 'host11'}\nManager Nodes are present in Cluster Nodes: True\nCluster Nodes contain all Manager Nodes: True\n</code></pre>"},{"location":"basics/data_structures/sets/#unions-and-intersections","title":"Unions and Intersections","text":"<p>The union of two sets is all the elements of both sets. The intersection of two sets is only the elements that appear in both sets. It is possible to use logical operators to perform unions and intersections (union is <code>set1 | set2</code>, while intersection is <code>set1 &amp; set2</code>), but Python provides useful methods for these operations. Below is a (somewhat contrived) example:</p> Set Unions and Intersections<pre><code>mechanic_tools = {\"wrench\", \"screwdriver\", \"hammer\", \"pliers\", \"jack\"}\ncarpenter_tools = {\"saw\", \"hammer\", \"chisel\", \"screwdriver\", \"level\"}\nprint(f\"Intersection: {mechanic_tools.intersection(carpenter_tools)}\") # (1)\nprint(f\"Union: {mechanic_tools.union(carpenter_tools)}\")\n</code></pre> <ol> <li>Maybe mechanics and carpenters can get along after all! \ud83d\ude04</li> </ol> <p>Returns:</p> <pre><code>Intersection: {'screwdriver', 'hammer'}\nUnion: {'saw', 'level', 'screwdriver', 'chisel', 'jack', 'hammer', 'pliers', 'wrench'}\n</code></pre>"},{"location":"basics/data_structures/sets/#difference-of-sets","title":"Difference of Sets","text":"<p>The difference of sets is all the elements in one set that do not exist in another. This can be calculated using arithmetic operators - <code>set1 - set2</code> would yield all the elements in <code>set1</code> that are not in <code>set2</code>.  Python also offers handy methods which are more explicit than the arithmetic operators (for most programmers).  To continue our contrive example from above:</p> Difference of Sets<pre><code>mechanic_tools = {\"wrench\", \"screwdriver\", \"hammer\", \"pliers\", \"jack\"}\ncarpenter_tools = {\"saw\", \"hammer\", \"chisel\", \"screwdriver\", \"level\"}\nprint(f\"Mechanic-only Tools: {mechanic_tools.difference(carpenter_tools)}\")\nprint(f\"Carpenter-only Tools: {carpenter_tools.difference(mechanic_tools)}\")\n</code></pre> <p>Returns:</p> <pre><code>Mechanic-only Tools: {'jack', 'pliers', 'wrench'}\nCarpenter-only Tools: {'saw', 'level', 'chisel'\n</code></pre>"},{"location":"basics/data_structures/sets/#disjoint","title":"Disjoint","text":"<p>If two sets do not have any elements in common, it is disjoint, meaning their union is empty. In Python, this can be a useful operation to ensure there is no duplication between two sets of data.</p> Testing Disjoint Sets<pre><code>s1 = {1, 2, 3}\ns2 = {4, 5, 6}\nprint(s1.isdisjoint(s2))\n</code></pre> <p>Returns:</p> <pre><code>True\n</code></pre>"},{"location":"basics/data_structures/sets/#symmetric-difference","title":"Symmetric Difference","text":"<p>The symmetric difference is all elements that are in either set, but not in both. It's essentially the opposite of intersection:</p> Symmetric Difference<pre><code>mechanic_tools = {\"wrench\", \"screwdriver\", \"hammer\", \"pliers\", \"jack\"}\ncarpenter_tools = {\"saw\", \"hammer\", \"chisel\", \"screwdriver\", \"level\"}\n\n# Elements unique to each set (not shared)\nunique_tools = mechanic_tools.symmetric_difference(carpenter_tools)\nprint(unique_tools)\n# {'saw', 'level', 'chisel', 'jack', 'pliers', 'wrench'}\n\n# Also available with ^ operator\nprint(mechanic_tools ^ carpenter_tools)\n# Same result\n</code></pre>"},{"location":"basics/data_structures/sets/#set-comprehensions","title":"Set Comprehensions","text":"<p>Just like list comprehensions, you can create sets with a concise syntax:</p> Set Comprehensions<pre><code># Basic set comprehension\nsquares = {x**2 for x in range(10)}\nprint(squares)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}\n\n# With filtering\neven_squares = {x**2 for x in range(10) if x % 2 == 0}\nprint(even_squares)  # {0, 4, 16, 36, 64}\n\n# Extract unique values from data\nemails = [\"alice@gmail.com\", \"bob@yahoo.com\", \"charlie@gmail.com\"]\ndomains = {email.split(\"@\")[1] for email in emails}\nprint(domains)  # {'gmail.com', 'yahoo.com'}\n</code></pre>"},{"location":"basics/data_structures/sets/#frozenset-immutable-sets","title":"Frozenset: Immutable Sets","text":"<p>A <code>frozenset</code> is an immutable version of a set. Since it's immutable (and therefore hashable), it can be used as a dictionary key or as an element of another set:</p> Frozenset Basics<pre><code># Create a frozenset\nfrozen = frozenset([1, 2, 3])\nprint(frozen)  # frozenset({1, 2, 3})\n\n# Cannot modify!\n# frozen.add(4)  # AttributeError: 'frozenset' object has no attribute 'add'\n\n# But all read operations work\nprint(2 in frozen)  # True\nprint(len(frozen))  # 3\n</code></pre>"},{"location":"basics/data_structures/sets/#frozenset-as-dictionary-key","title":"Frozenset as Dictionary Key","text":"Frozenset as Dict Key<pre><code># Regular sets CANNOT be dict keys\n# {{\"a\", \"b\"}: \"value\"}  # TypeError: unhashable type: 'set'\n\n# Frozensets CAN be dict keys\npermissions = {\n    frozenset([\"read\"]): \"viewer\",\n    frozenset([\"read\", \"write\"]): \"editor\",\n    frozenset([\"read\", \"write\", \"delete\"]): \"admin\"\n}\n\nuser_perms = frozenset([\"read\", \"write\"])\nprint(permissions[user_perms])  # editor\n</code></pre>"},{"location":"basics/data_structures/sets/#sets-of-sets-using-frozenset","title":"Sets of Sets (Using Frozenset)","text":"Nested Sets with Frozenset<pre><code># Create a set of frozensets\npower_set = {\n    frozenset(),\n    frozenset([1]),\n    frozenset([2]),\n    frozenset([1, 2])\n}\n\nprint(power_set)\n# {frozenset(), frozenset({2}), frozenset({1}), frozenset({1, 2})}\n\n# Check if a subset exists\nprint(frozenset([1]) in power_set)  # True\n</code></pre>"},{"location":"basics/data_structures/sets/#when-to-use-frozenset","title":"When to Use Frozenset","text":"Use <code>set</code> when... Use <code>frozenset</code> when... You need to add/remove elements The set won't change It's a working collection You need it as a dict key Modifying in loops You need a set of sets Building up results Representing fixed categories"},{"location":"basics/data_structures/sets/#operators-summary","title":"Operators Summary","text":"Operation Method Operator Result Union <code>a.union(b)</code> <code>a \\| b</code> All elements from both Intersection <code>a.intersection(b)</code> <code>a &amp; b</code> Elements in both Difference <code>a.difference(b)</code> <code>a - b</code> Elements in a, not in b Symmetric Diff <code>a.symmetric_difference(b)</code> <code>a ^ b</code> Elements in either, not both Subset <code>a.issubset(b)</code> <code>a &lt;= b</code> Is a contained in b? Proper Subset \u2014 <code>a &lt; b</code> a \u2282 b (a is smaller) Superset <code>a.issuperset(b)</code> <code>a &gt;= b</code> Does a contain b?"},{"location":"basics/data_structures/sets/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Creating <code>{1, 2, 3}</code> or <code>set()</code> (empty set must use <code>set()</code>) No duplicates Automatically removes duplicate elements No order Elements have no guaranteed order Adding <code>add()</code> for one, <code>update()</code> for many Removing <code>discard()</code> (safe) or <code>remove()</code> (raises error) Union <code>a \\| b</code> \u2014 all elements from both Intersection <code>a &amp; b</code> \u2014 elements in both Difference <code>a - b</code> \u2014 elements in a, not in b Symmetric diff <code>a ^ b</code> \u2014 elements in either, not both Frozenset Immutable set, can be dict key Performance O(1) membership testing \u2014 very fast! \u26a1"},{"location":"basics/data_structures/slicing_sequences/","title":"Slicing Sequences","text":"<p>Slicing is a powerful technique that allows you to extract specific portions of data from Python sequences such as lists, strings, and tuples. \ud83d\udd2a (The good kind of slicing, not the kitchen mishap kind.) It provides you with the ability to finely control what data you need, whether it\u2019s from the beginning, end, or anywhere in between. This slicing capability is governed by both positive and negative index systems, making it a versatile tool for data manipulation.</p>"},{"location":"basics/data_structures/slicing_sequences/#slicing-index-system","title":"Slicing Index System","text":"<pre><code>Positive index system\n  0      1      2      3      4      5      6\nNegative index system\n -7     -6     -5     -4     -3     -2     -1\n</code></pre> <p>Consider the following index systems for a list:</p> Indexing Sequences<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\nprint(days[-2])\nprint(days[2])\n</code></pre> <p>Results in:</p> <pre><code>Saturday\nWednesday\n</code></pre> <p>Easily access specific portions of a list using slicing. For example, to access the 2nd, 3rd, and 4th items of a list named days, you can use the following code:</p> Slicing Lists<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\nsliced_days = days[1:4]\nprint(sliced_days)\n</code></pre> <p>Would output:</p> <pre><code>['Tuesday', 'Wednesday', 'Thursday']\n</code></pre> <p>Retrieve the first three items of a list by simply omitting the starting index:</p> Retrieving First 3 Items in a List<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\nfirst_three_days = days[:3]\nprint(first_three_days)\n</code></pre> <p>Would result in:</p> <pre><code>['Monday', 'Tuesday', 'Wednesday']\n</code></pre> <p>To get the last three items, you can use negative indexing:</p> Negative Slicing of Lists<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\nlast_three_days = days[-3:]\nprint(last_three_days)\n</code></pre> <p>Outputs:</p> <pre><code>['Friday', 'Saturday', 'Sunday']\n</code></pre> <p>For everything except the last item, exclude it by slicing until one element from the end:</p> Exclude the Last Item in a List<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\neverything_but_last = days[:-1]\nprint(everything_but_last)\n</code></pre> <p>Results in:</p> <pre><code>['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n</code></pre> <p>Similarly, you can exclude the last two items:</p> Exclude the Last 2 Items in a List<pre><code>days = [\"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    ]\n\neverything_but_last_two = days[:-2]\nprint(everything_but_last_two)\n</code></pre> <p>Returns:</p> <pre><code>['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#slicing-strings-and-tuples","title":"Slicing Strings and Tuples","text":"<p>Strings and tuples share the same slicing principles as lists. You can effortlessly extract portions of text from a string or elements from a tuple using slicing. For example, consider this example:</p> Slicing Strings<pre><code>text = \"Hello, World!\"\nsliced_text = text[7:12]\nprint(sliced_text)\n</code></pre> <p>Would output:</p> <pre><code>World\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#step-slicing","title":"Step Slicing","text":"<p>The full slice syntax is <code>sequence[start:stop:step]</code>. The <code>step</code> parameter controls how many items to skip:</p> Step Slicing<pre><code>numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Every second item\nprint(numbers[::2])   # [0, 2, 4, 6, 8]\n\n# Every third item\nprint(numbers[::3])   # [0, 3, 6, 9]\n\n# Every second item, starting from index 1\nprint(numbers[1::2])  # [1, 3, 5, 7, 9]\n\n# From index 1 to 7, every second item\nprint(numbers[1:8:2])  # [1, 3, 5, 7]\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#reversing-with-negative-step","title":"Reversing with Negative Step","text":"<p>A negative step traverses the sequence backwards. This is the Pythonic way to reverse:</p> Negative Step (Reversing)<pre><code>numbers = [0, 1, 2, 3, 4, 5]\n\n# Reverse the entire sequence\nprint(numbers[::-1])  # [5, 4, 3, 2, 1, 0]\n\n# Reverse a string\ntext = \"Hello, World!\"\nprint(text[::-1])  # !dlroW ,olleH\n\n# Every second item, reversed\nprint(numbers[::-2])  # [5, 3, 1]\n\n# From index 4 to 1, backwards\nprint(numbers[4:0:-1])  # [4, 3, 2, 1]\n</code></pre> <p>Palindrome Check</p> <p>The <code>[::-1]</code> trick makes checking palindromes elegant:</p> <pre><code>def is_palindrome(s):\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\nprint(is_palindrome(\"A man a plan a canal Panama\"))  # True\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#slice-assignment","title":"Slice Assignment","text":"<p>For mutable sequences like lists, you can assign to a slice to modify multiple elements at once:</p> Basic Slice Assignment<pre><code>numbers = [0, 1, 2, 3, 4, 5]\n\n# Replace a portion\nnumbers[1:4] = [10, 20, 30]\nprint(numbers)  # [0, 10, 20, 30, 4, 5]\n\n# Replace with different length (insert/delete)\nnumbers[1:4] = [100]\nprint(numbers)  # [0, 100, 4, 5]\n\n# Insert without removing\nnumbers[1:1] = [7, 8, 9]\nprint(numbers)  # [0, 7, 8, 9, 100, 4, 5]\n\n# Delete a portion\nnumbers[1:4] = []\nprint(numbers)  # [0, 100, 4, 5]\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#replacing-all-elements","title":"Replacing All Elements","text":"Replacing All Elements<pre><code>original = [1, 2, 3]\nbackup = original  # Both point to same list\n\n# This creates a NEW list (backup still points to old one)\noriginal = [4, 5, 6]\nprint(backup)  # [1, 2, 3]\n\n# This modifies IN PLACE (backup sees the change)\noriginal = [1, 2, 3]\nbackup = original\noriginal[:] = [4, 5, 6]\nprint(backup)  # [4, 5, 6] \u2014 same object, modified!\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#slice-objects","title":"Slice Objects","text":"<p>You can create reusable slice objects:</p> Slice Objects<pre><code># Create a slice object\nfirst_three = slice(0, 3)\nevery_other = slice(None, None, 2)\nlast_two = slice(-2, None)\n\ndata = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(data[first_three])   # [0, 1, 2]\nprint(data[every_other])   # [0, 2, 4, 6, 8]\nprint(data[last_two])      # [8, 9]\n\n# Useful when same slice is used on multiple sequences\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\"]\nscores = [85, 92, 78, 95, 88]\n\ntop_three = slice(0, 3)\nprint(names[top_three])   # ['Alice', 'Bob', 'Charlie']\nprint(scores[top_three])  # [85, 92, 78]\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#common-slicing-patterns","title":"Common Slicing Patterns","text":"<p>These patterns come up constantly. Memorize them like your coffee order \u2014 you'll use them every day.</p> Common Patterns<pre><code>data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# First N items\nfirst_5 = data[:5]       # [0, 1, 2, 3, 4]\n\n# Last N items\nlast_3 = data[-3:]       # [7, 8, 9]\n\n# All except first N\nskip_first_2 = data[2:]  # [2, 3, 4, 5, 6, 7, 8, 9]\n\n# All except last N\nskip_last_2 = data[:-2]  # [0, 1, 2, 3, 4, 5, 6, 7]\n\n# Middle portion\nmiddle = data[2:-2]      # [2, 3, 4, 5, 6, 7]\n\n# Shallow copy\ncopy = data[:]           # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Reverse\nreversed_data = data[::-1]  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#slicing-2d-structures","title":"Slicing 2D Structures","text":"<p>When working with lists of lists (matrices), you need to slice each dimension:</p> Slicing 2D Data<pre><code>matrix = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12]\n]\n\n# Get first two rows\nprint(matrix[:2])\n# [[1, 2, 3, 4], [5, 6, 7, 8]]\n\n# Get first column (need list comprehension)\nfirst_col = [row[0] for row in matrix]\nprint(first_col)  # [1, 5, 9]\n\n# Get a sub-matrix (first 2 rows, first 2 columns)\nsubmatrix = [row[:2] for row in matrix[:2]]\nprint(submatrix)  # [[1, 2], [5, 6]]\n</code></pre> <p>For Heavy Matrix Work</p> <p>For serious matrix operations, use NumPy which supports true multi-dimensional slicing:</p> <pre><code>import numpy as np\narr = np.array(matrix)\nprint(arr[:2, :2])  # First 2 rows, first 2 columns\n</code></pre>"},{"location":"basics/data_structures/slicing_sequences/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Basic syntax <code>sequence[start:stop]</code> \u2014 stop is exclusive Omitting indices <code>[:3]</code> from start, <code>[3:]</code> to end, <code>[:]</code> copy all Negative indices <code>-1</code> is last, <code>-2</code> is second-to-last Step <code>[::2]</code> every other, <code>[::3]</code> every third Reverse <code>[::-1]</code> reverses any sequence Slice assignment <code>list[1:4] = [a, b]</code> \u2014 replace portion In-place modify <code>list[:] = [...]</code> modifies same object Slice objects <code>s = slice(0, 3)</code> \u2014 reusable slices Works on Lists, tuples, strings \u2014 any sequence"},{"location":"basics/data_structures/tuples/","title":"Tuples","text":"<p>Tuples, similar to lists, are a sequenced collection that provides a means to collect and organize data. However, their immutability sets tuples apart \u2013 once created, the elements within a tuple cannot be modified. Set in stone. \ud83e\udea8 In this guide, we\u2019ll delve into what tuples are, explore why they are used, and demonstrate some practical use cases for these unchangeable data structures.</p>"},{"location":"basics/data_structures/tuples/#understanding-tuples","title":"Understanding Tuples","text":"<p>A <code>tuple</code> is a collection of elements, just like a list, but it differs crucially: it cannot be changed or altered once declared. This immutability makes tuples an ideal choice for ensuring that the data remains constant throughout your program\u2019s execution. Consider tuples as containers for values that should remain fixed, such as the results obtained from a database SELECT statement in SQL. These results might be crucial to your Python program, but you want to guarantee their integrity and prevent unintentional modifications.</p>"},{"location":"basics/data_structures/tuples/#creating-tuples","title":"Creating Tuples","text":"<p>Creating a tuple in Python is relatively straightforward. Instead of using square brackets, as you would with a list, you use parentheses to define a tuple. Here\u2019s how you can create tuples to store server names and ages:</p> Basic Tuples<pre><code>servers = ('web01', 'web02', 'app01', 'db01')\nages = (12, 19, 32, 41)\n</code></pre> <p>Once you\u2019ve created these tuples, you can access their elements using indexing, just like a list. For example, to retrieve the first element from the ages tuple, you can use:</p> Retrieving Elements in a Tuple<pre><code>print(ages[0])\n</code></pre> <p>Would result in:</p> <pre><code>12\n</code></pre>"},{"location":"basics/data_structures/tuples/#use-cases-for-tuples","title":"Use Cases for Tuples","text":"<p>Now, let\u2019s explore some practical use cases for tuples.</p> <ul> <li>Store Constant Values: Lsuch as mathematical constants or configuration settings,   ensuring that they remain unchanged throughout the program\u2019s execution.</li> <li>Unpacking Contstants - Returning Multiple Values: Functions in Python can return multiple   values as a tuple. This allows you to efficiently pack and unpack data when calling and   receiving function results.</li> </ul> Tuples Use Case: Unpacking Constants<pre><code>def get_user_info(user_id):\n    # retrieve user data\n    return ('John', 'Doe', 30)\n\nfirst_name, last_name, age = get_user_info(123)\n</code></pre> <ul> <li>Database Results: As mentioned earlier, tuples are perfect for holding database query results.   They maintain the integrity of fetched data while allowing you to work with it effectively.</li> <li>Coordinate Pairs: Tuples can represent coordinates or pairs of values, which is handy in   applications involving geometry or mapping.</li> </ul> Tuples Use Case: Coordinate Pairs<pre><code>lat = 43.642567\nlong = -79.387054\ncn_tower = (lat, long) # immutable\nprint(f\"The CN Tower stands at {cn_tower[0]} latitude, and {cn_tower[1]} longitude.\")\n</code></pre> <p>Would return:</p> <pre><code>The CN Tower stands at 43.642567 latitude, and -79.387054 longitude.\n</code></pre>"},{"location":"basics/data_structures/tuples/#tuple-methods","title":"Tuple Methods","text":"<p>Tuples have only two methods (since they're immutable, they don't need many):</p> Tuple Methods<pre><code>numbers = (1, 2, 3, 2, 4, 2, 5)\n\n# Count occurrences\nprint(numbers.count(2))  # 3\n\n# Find index of first occurrence\nprint(numbers.index(4))  # 4\n# numbers.index(99)  # ValueError if not found!\n</code></pre>"},{"location":"basics/data_structures/tuples/#tuple-unpacking","title":"Tuple Unpacking","text":"<p>Unpacking is one of the most powerful features of tuples. It lets you assign multiple variables at once:</p> Basic Unpacking<pre><code># Basic unpacking\npoint = (10, 20)\nx, y = point\nprint(f\"x={x}, y={y}\")  # x=10, y=20\n\n# Unpacking in loops\ncoordinates = [(1, 2), (3, 4), (5, 6)]\nfor x, y in coordinates:\n    print(f\"Point: ({x}, {y})\")\n\n# Swap variables without a temp!\na, b = 1, 2\na, b = b, a  # Magic! \u2728\nprint(f\"a={a}, b={b}\")  # a=2, b=1\n</code></pre>"},{"location":"basics/data_structures/tuples/#extended-unpacking-with","title":"Extended Unpacking with *","text":"<p>Python 3 introduced the <code>*</code> operator for catching \"the rest\":</p> Extended Unpacking<pre><code># Grab first and rest\nfirst, *rest = (1, 2, 3, 4, 5)\nprint(first)  # 1\nprint(rest)   # [2, 3, 4, 5] \u2014 note: becomes a list!\n\n# Grab first, last, and middle\nfirst, *middle, last = (1, 2, 3, 4, 5)\nprint(first)   # 1\nprint(middle)  # [2, 3, 4]\nprint(last)    # 5\n\n# Ignore parts you don't need\nname, _, _, email = (\"Alice\", \"Developer\", \"NYC\", \"alice@example.com\")\nprint(f\"{name}: {email}\")\n</code></pre>"},{"location":"basics/data_structures/tuples/#unpacking-in-function-calls","title":"Unpacking in Function Calls","text":"Unpacking in Function Calls<pre><code>def greet(first_name, last_name, age):\n    print(f\"Hello, {first_name} {last_name}! You are {age}.\")\n\nperson = (\"Alice\", \"Smith\", 30)\ngreet(*person)  # Unpacks tuple as positional arguments\n# Hello, Alice Smith! You are 30.\n</code></pre>"},{"location":"basics/data_structures/tuples/#named-tuples","title":"Named Tuples","text":"<p>Regular tuples access elements by index, which can be unclear. Named tuples give you the best of both worlds \u2014 tuple efficiency with named access like a class:</p> Named Tuples<pre><code>from collections import namedtuple\n\n# Define a named tuple type\nPoint = namedtuple('Point', ['x', 'y'])\nPerson = namedtuple('Person', 'name age city')  # String also works\n\n# Create instances\np = Point(10, 20)\nalice = Person('Alice', 30, 'NYC')\n\n# Access by name (much clearer!)\nprint(p.x, p.y)           # 10 20\nprint(alice.name)         # Alice\nprint(alice.age)          # 30\n\n# Still works like a regular tuple\nprint(p[0], p[1])         # 10 20\nx, y = p                  # Unpacking works\nprint(len(alice))         # 3\n</code></pre>"},{"location":"basics/data_structures/tuples/#named-tuple-methods","title":"Named Tuple Methods","text":"Named Tuple Features<pre><code>from collections import namedtuple\n\nPerson = namedtuple('Person', 'name age city')\nalice = Person('Alice', 30, 'NYC')\n\n# Convert to dictionary\nprint(alice._asdict())\n# {'name': 'Alice', 'age': 30, 'city': 'NYC'}\n\n# Create a modified copy (remember, tuples are immutable!)\nbob = alice._replace(name='Bob', age=25)\nprint(bob)  # Person(name='Bob', age=25, city='NYC')\n\n# Get field names\nprint(Person._fields)  # ('name', 'age', 'city')\n\n# Create from an iterable\ndata = ['Charlie', 35, 'LA']\ncharlie = Person._make(data)\nprint(charlie)  # Person(name='Charlie', age=35, city='LA')\n</code></pre>"},{"location":"basics/data_structures/tuples/#typingnamedtuple-modern-alternative","title":"typing.NamedTuple (Modern Alternative)","text":"<p>Python 3.6+ offers a class-based syntax with type hints:</p> typing.NamedTuple<pre><code>from typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: float\n    y: float\n    label: str = \"origin\"  # Default value!\n\np1 = Point(10.0, 20.0)\np2 = Point(5.0, 5.0, \"center\")\n\nprint(p1)        # Point(x=10.0, y=20.0, label='origin')\nprint(p1.label)  # origin\nprint(p2.label)  # center\n</code></pre> <p>When to Use Named Tuples</p> <p>Named tuples are perfect for:</p> <ul> <li>Simple data containers (coordinates, RGB colors, records)</li> <li>Return values from functions with multiple fields</li> <li>Replacing small classes that just hold data</li> <li>Making code more self-documenting</li> </ul>"},{"location":"basics/data_structures/tuples/#tuples-vs-lists-when-to-use-each","title":"Tuples vs Lists: When to Use Each","text":"<p>Choosing between tuples and lists is like choosing between a good espresso and a cheap pizza \u2014 one is refined and purposeful, the other is... flexible but sometimes regrettable.</p> Use Tuples When... Use Lists When... Data shouldn't change Data needs to be modified Representing fixed collections (coordinates, RGB) Managing dynamic collections Dictionary keys (tuples are hashable!) Order matters but items change Function return values with multiple items Stacks, queues, or buffers Slightly better performance matters You need append/remove/sort Tuples as Dictionary Keys<pre><code># Tuples can be dict keys (they're hashable)\nlocations = {\n    (40.7128, -74.0060): \"New York\",\n    (51.5074, -0.1278): \"London\",\n    (35.6762, 139.6503): \"Tokyo\"\n}\n\nprint(locations[(40.7128, -74.0060)])  # New York\n\n# Lists CANNOT be dict keys\n# {[1, 2]: \"value\"}  # TypeError: unhashable type: 'list'\n</code></pre>"},{"location":"basics/data_structures/tuples/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Creating <code>(1, 2, 3)</code> or <code>tuple()</code>, single item needs comma: <code>(1,)</code> Immutable Cannot add, remove, or change elements Methods Only <code>count()</code> and <code>index()</code> Unpacking <code>x, y = point</code> \u2014 assign multiple variables at once Extended unpacking <code>first, *rest = items</code> \u2014 catch remaining items Named tuples <code>namedtuple('Point', ['x', 'y'])</code> \u2014 access by name Hashable Can be used as dict keys (lists cannot) Performance Slightly faster and less memory than lists"},{"location":"basics/data_types/booleans/","title":"Booleans","text":"<p>Validate user passwords. Check if a file exists. Determine whether to show admin features. Test if a number is within range. Filter search results. Control loop execution. Every one of these requires answering yes/no questions in code.</p> <p>Booleans are Python's data type for truth values\u2014<code>True</code> or <code>False</code>. They're the foundation of every decision your program makes, powering <code>if</code> statements, <code>while</code> loops, data filtering, and conditional logic throughout your code.</p>"},{"location":"basics/data_types/booleans/#what-is-a-boolean","title":"What is a Boolean?","text":"<p>A boolean (<code>bool</code> type) represents one of two values: <code>True</code> or <code>False</code>:</p> Creating Booleans<pre><code>is_authenticated = True  # (1)!\nhas_permission = False\nis_valid = True\n</code></pre> <ol> <li>Booleans must be capitalized\u2014<code>True</code> and <code>False</code>, not <code>true</code>/<code>false</code>. Python will raise <code>NameError</code> for lowercase versions.</li> </ol> <p>Most booleans aren't assigned directly\u2014they're the result of comparisons, function returns, or logical operations:</p> Booleans from Comparisons<pre><code>age = 25\nis_adult = age &gt;= 18      # (1)!\nprint(is_adult)           # True\n\nuser_count = 0\nhas_users = user_count &gt; 0  # (2)!\nprint(has_users)          # False\n</code></pre> <ol> <li>Comparison operators (<code>&gt;=</code>, <code>==</code>, <code>!=</code>, etc.) return boolean values</li> <li>Evaluates to <code>False</code> because 0 is not greater than 0</li> </ol>"},{"location":"basics/data_types/booleans/#why-booleans-matter","title":"Why Booleans Matter","text":"<p>Booleans enable decision-making in code:</p> <ul> <li>Authentication: Is the user logged in? Do they have permission?</li> <li>Validation: Is the email valid? Is the form complete? Is the input within range?</li> <li>Control flow: Should the loop continue? Should this branch execute?</li> <li>Filtering: Does this item match criteria? Should it appear in results?</li> <li>State management: Is the connection active? Is data loaded? Is processing complete?</li> </ul> <p>Without booleans, programs couldn't make decisions. Every <code>if</code> statement, every <code>loop</code> condition, every filter\u2014all built on boolean logic.</p>"},{"location":"basics/data_types/booleans/#comparison-operators","title":"Comparison Operators","text":"<p>Check if a score passes a threshold. Verify a password matches. Test if an age qualifies for a discount. Comparisons return boolean values that drive program logic:</p> Comparison Operators<pre><code>x = 10\ny = 5\n\nprint(x == y)   # (1)!\nprint(x != y)   # (2)!\nprint(x &gt; y)    # (3)!\nprint(x &lt; y)\nprint(x &gt;= y)\nprint(x &lt;= y)\n</code></pre> <ol> <li><code>==</code> tests equality\u2014returns <code>False</code> (10 does not equal 5)</li> <li><code>!=</code> tests inequality\u2014returns <code>True</code> (10 is not equal to 5)</li> <li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> compare magnitude\u2014work with numbers, strings, and other comparable types</li> </ol> <p>These operators work with numbers, strings (alphabetical order), and other comparable types:</p> Comparing Strings<pre><code>print(\"apple\" &lt; \"banana\")   # (1)!\nprint(\"apple\" &lt; \"Apple\")    # (2)!\nprint(\"10\" &lt; \"9\")           # (3)!\n</code></pre> <ol> <li>Returns <code>True</code>\u2014'a' comes before 'b' alphabetically</li> <li>Returns <code>False</code>\u2014lowercase letters come after uppercase in ASCII/Unicode</li> <li>Returns <code>True</code>\u2014string comparison is character-by-character: '1' &lt; '9' in ASCII</li> </ol> <p>String vs Number Comparison</p> <p>Comparing strings that look like numbers can be surprising. <code>\"10\" &lt; \"9\"</code> is <code>True</code> because string comparison is character-by-character, and <code>'1'</code> comes before <code>'9'</code>. If you need numeric comparison, convert to <code>int</code> or <code>float</code> first.</p>"},{"location":"basics/data_types/booleans/#chained-comparisons","title":"Chained Comparisons","text":"<p>Validate that a value falls within a range. Check if a date is between two bounds. Python lets you chain comparisons naturally:</p> Chained Comparisons<pre><code>age = 25\n\n# Instead of: age &gt;= 18 and age &lt;= 65\nprint(18 &lt;= age &lt;= 65)  # (1)!\n\ntemperature = 72\nprint(60 &lt; temperature &lt; 80)  # (2)!\n</code></pre> <ol> <li>Returns <code>True</code>\u2014reads like mathematical notation: \"is age between 18 and 65?\"</li> <li>Returns <code>True</code>\u2014multiple comparisons in one expression</li> </ol>"},{"location":"basics/data_types/booleans/#logical-operators","title":"Logical Operators","text":"<p>Require both username AND password. Grant access if admin OR moderator. Deny entry if NOT authenticated. Combining conditions is essential for complex logic\u2014Python provides <code>and</code>, <code>or</code>, and <code>not</code>:</p>"},{"location":"basics/data_types/booleans/#the-and-operator","title":"The <code>and</code> Operator","text":"<p>Both conditions must be <code>True</code> for the result to be <code>True</code>:</p> The and Operator<pre><code>age = 25\nhas_license = True\n\ncan_drive = age &gt;= 16 and has_license  # (1)!\nprint(can_drive)  # True\n\ncan_rent_car = age &gt;= 25 and has_license\nprint(can_rent_car)  # True\n</code></pre> <ol> <li>Both conditions must be true\u2014age must be at least 16 AND license must exist</li> </ol> A B A and B True True True True False False False True False False False False"},{"location":"basics/data_types/booleans/#the-or-operator","title":"The <code>or</code> Operator","text":"<p>At least one condition must be <code>True</code> for the result to be <code>True</code>:</p> The or Operator<pre><code>is_weekend = True\nis_holiday = False\n\ncan_sleep_in = is_weekend or is_holiday  # (1)!\nprint(can_sleep_in)  # True\n</code></pre> <ol> <li>Only one condition needs to be true\u2014either weekend OR holiday allows sleeping in</li> </ol> A B A or B True True True True False True False True True False False False"},{"location":"basics/data_types/booleans/#the-not-operator","title":"The <code>not</code> Operator","text":"<p>Flips <code>True</code> to <code>False</code> and vice versa:</p> The not Operator<pre><code>is_raining = False\n\nif not is_raining:  # (1)!\n    print(\"Let's go for a walk!\")\n\n# Double negation\nprint(not not True)  # (2)!\n</code></pre> <ol> <li><code>not</code> inverts the boolean\u2014<code>not False</code> becomes <code>True</code></li> <li>Returns <code>True</code>\u2014two <code>not</code> operators cancel out</li> </ol>"},{"location":"basics/data_types/booleans/#combining-operators","title":"Combining Operators","text":"<p>Check complex eligibility. Validate multiple requirements. Build sophisticated filters\u2014combine operators for precise logic:</p> Complex Conditions<pre><code>age = 25\nis_student = True\nhas_coupon = False\n\n# Gets discount if: student, OR has coupon, OR is senior (65+)\ngets_discount = is_student or has_coupon or age &gt;= 65  # (1)!\nprint(gets_discount)  # True\n\n# Can enter if: adult AND (member OR has ticket)\nis_adult = age &gt;= 18\nis_member = False\nhas_ticket = True\n\ncan_enter = is_adult and (is_member or has_ticket)  # (2)!\nprint(can_enter)  # True\n</code></pre> <ol> <li>Multiple <code>or</code> conditions\u2014any one being true makes the whole expression true</li> <li>Parentheses group conditions\u2014must be adult AND (member OR ticket holder)</li> </ol> <p>Use Parentheses for Clarity</p> <p>While Python has operator precedence rules (<code>not</code> before <code>and</code> before <code>or</code>), explicit parentheses make your intent clear and prevent bugs.</p>"},{"location":"basics/data_types/booleans/#truthiness-what-python-considers-true-or-false","title":"Truthiness: What Python Considers True or False","text":"<p>Check if a list has items without <code>len()</code>. Validate that a string isn't empty without comparison. Test for <code>None</code> in conditionals. Python's \"truthiness\" lets every value act as a boolean in context.</p>"},{"location":"basics/data_types/booleans/#falsy-values","title":"Falsy Values","text":"<p>These values are considered <code>False</code> when used in a boolean context:</p> Falsy Values<pre><code># All of these are \"falsy\"\nprint(bool(False))     # (1)!\nprint(bool(None))      # (2)!\nprint(bool(0))         # (3)!\nprint(bool(0.0))\nprint(bool(\"\"))        # (4)!\nprint(bool([]))        # (5)!\nprint(bool({}))\nprint(bool(set()))\nprint(bool(()))\n</code></pre> <ol> <li><code>False</code> is obviously falsy</li> <li><code>None</code> (absence of value) is falsy\u2014see None type</li> <li>Zero in any numeric form (<code>0</code>, <code>0.0</code>) is falsy</li> <li>Empty string is falsy</li> <li>Empty collections (lists, dicts, sets, tuples) are falsy</li> </ol>"},{"location":"basics/data_types/booleans/#truthy-values","title":"Truthy Values","text":"<p>Everything else is considered <code>True</code>:</p> Truthy Values<pre><code># All of these are \"truthy\"\nprint(bool(True))      # True \u2014 obviously\nprint(bool(1))         # (1)!\nprint(bool(-1))        # (2)!\nprint(bool(3.14))\nprint(bool(\"hello\"))   # (3)!\nprint(bool(\" \"))       # (4)!\nprint(bool([1, 2]))    # (5)!\nprint(bool({\"a\": 1}))\n</code></pre> <ol> <li>Any non-zero number is truthy</li> <li>Negative numbers are truthy too!</li> <li>Non-empty strings are truthy</li> <li>String with just a space is truthy (not empty!)</li> <li>Non-empty collections are truthy</li> </ol>"},{"location":"basics/data_types/booleans/#why-truthiness-matters","title":"Why Truthiness Matters","text":"<p>Truthiness allows for elegant, Pythonic code:</p> Pythonic Truthiness<pre><code># Instead of:\nif len(my_list) &gt; 0:  # (1)!\n    print(\"List has items\")\n\n# Write:\nif my_list:  # (2)!\n    print(\"List has items\")\n\n# Instead of:\nif name != \"\":\n    print(f\"Hello, {name}\")\n\n# Write:\nif name:  # (3)!\n    print(f\"Hello, {name}\")\n\n# Checking for None\nresult = some_function()\nif result is not None:  # (4)!\n    process(result)\n\n# Or simply (if None and other falsy values should be skipped):\nif result:  # (5)!\n    process(result)\n</code></pre> <ol> <li>Verbose\u2014explicitly checking length</li> <li>Pythonic\u2014empty list is falsy, non-empty is truthy</li> <li>Pythonic\u2014empty string is falsy</li> <li>Explicit None check\u2014use when distinguishing None from other falsy values (0, \"\", etc.)</li> <li>Truthiness check\u2014simpler but treats 0, \"\", [], etc. the same as None</li> </ol> <p>Truthiness vs. Explicit Comparison</p> <p>Be careful! <code>if x:</code> and <code>if x == True:</code> are different:</p> <pre><code>x = 1\nprint(x == True)   # True \u2014 because bool(1) equals True\nprint(x is True)   # False \u2014 1 is not the same object as True\n\nx = 2\nprint(x == True)   # False \u2014 2 doesn't equal True\nprint(bool(x))     # True \u2014 but 2 is still truthy!\n</code></pre> <p>When checking truthiness, use <code>if x:</code>. When checking for the actual boolean value, use <code>if x is True:</code>.</p>"},{"location":"basics/data_types/booleans/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>Skip expensive database queries. Avoid accessing attributes on None. Prevent unnecessary API calls. Python's \"short-circuit evaluation\" stops evaluating as soon as the result is known\u2014boosting performance and safety:</p>"},{"location":"basics/data_types/booleans/#how-and-short-circuits","title":"How <code>and</code> Short-Circuits","text":"<p>With <code>and</code>, if the first value is falsy, Python doesn't bother checking the second:</p> and Short-Circuiting<pre><code>def expensive_check():\n    print(\"Running expensive check...\")  # (1)!\n    return True\n\n# This prints nothing \u2014 expensive_check() never runs\nresult = False and expensive_check()  # (2)!\nprint(result)  # False\n</code></pre> <ol> <li>This function would be expensive to run (database query, API call, etc.)</li> <li>Since <code>False and anything</code> is always <code>False</code>, Python skips the function call entirely</li> </ol>"},{"location":"basics/data_types/booleans/#how-or-short-circuits","title":"How <code>or</code> Short-Circuits","text":"<p>With <code>or</code>, if the first value is truthy, Python doesn't bother checking the second:</p> or Short-Circuiting<pre><code>def expensive_check():\n    print(\"Running expensive check...\")\n    return False\n\n# This prints nothing \u2014 expensive_check() never runs\nresult = True or expensive_check()  # (1)!\nprint(result)  # True\n</code></pre> <ol> <li>Since <code>True or anything</code> is always <code>True</code>, Python skips the function call</li> </ol>"},{"location":"basics/data_types/booleans/#practical-uses","title":"Practical Uses","text":"<p>Short-circuiting enables some elegant patterns:</p> Short-Circuit Patterns<pre><code># Safe attribute access\nuser = None\n# This would crash: user.name\n# But this is safe:\nname = user and user.name  # (1)!\n\n# Default values\nusername = input_name or \"Anonymous\"  # (2)!\n\n# Guard clauses in functions\ndef process_items(items):  # (3)!\n    if not items:  # (4)!\n        return []\n    # ... rest of function\n</code></pre> <ol> <li>Returns <code>None</code> without crashing\u2014if <code>user</code> is falsy, Python stops evaluating and returns <code>user</code> (None)</li> <li>Use \"Anonymous\" if <code>input_name</code> is empty/None\u2014the <code>or</code> pattern provides a default value</li> <li>See functions for more on defining and using functions</li> <li>Short-circuits the rest of the function if items is empty/None\u2014guard clauses prevent errors</li> </ol> <p>The <code>or</code> Default Pattern</p> <p><code>value or default</code> is a common Python idiom for providing default values:</p> <pre><code>name = user_input or \"Guest\"\nport = config.get(\"port\") or 8080\n</code></pre> <p>But be careful \u2014 this replaces any falsy value, including <code>0</code> or <code>\"\"</code> which might be intentional. For more control, use <code>value if value is not None else default</code>.</p>"},{"location":"basics/data_types/booleans/#the-bool-function","title":"The <code>bool()</code> Function","text":"<p>You can explicitly convert any value to a boolean using <code>bool()</code>:</p> Using bool()<pre><code>print(bool(42))        # (1)!\nprint(bool(\"\"))        # (2)!\nprint(bool([1, 2, 3])) # (3)!\n\n# Useful for debugging truthiness\nmystery_value = some_function()\nprint(f\"Value: {mystery_value}, Truthy: {bool(mystery_value)}\")  # (4)!\n</code></pre> <ol> <li>Returns <code>True</code>\u2014any non-zero number is truthy</li> <li>Returns <code>False</code>\u2014empty string is falsy</li> <li>Returns <code>True</code>\u2014non-empty list is truthy</li> <li>Helpful debugging pattern to see both the value and its boolean interpretation</li> </ol>"},{"location":"basics/data_types/booleans/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Comparison Operators <p>What does <code>5 &lt; 10 &lt; 15</code> evaluate to?</p> Answer <p>It returns <code>True</code>. This is a chained comparison that checks if <code>5 &lt; 10</code> AND <code>10 &lt; 15</code>. Both conditions are true, so the entire expression is <code>True</code>. This is equivalent to <code>5 &lt; 10 and 10 &lt; 15</code>, but more readable.</p> Practice Problem 2: Truthiness <p>Which of these values are truthy in Python: <code>0</code>, <code>[]</code>, <code>\" \"</code> (space), <code>False</code>, <code>1</code>, <code>None</code>?</p> Answer <p>Only <code>\" \"</code> (string with a space) and <code>1</code> are truthy.</p> <ul> <li><code>0</code> is falsy (zero is always falsy)</li> <li><code>[]</code> is falsy (empty list)</li> <li><code>\" \"</code> is truthy (non-empty string\u2014even just whitespace counts!)</li> <li><code>False</code> is falsy (obviously)</li> <li><code>1</code> is truthy (non-zero number)</li> <li><code>None</code> is falsy (absence of value)</li> </ul> Practice Problem 3: Short-Circuit Evaluation <p>What will this code print?</p> <pre><code>result = [] or [1, 2, 3]\nprint(result)\n</code></pre> Answer <p>It prints <code>[1, 2, 3]</code>.</p> <p>The <code>or</code> operator returns the first truthy value. Since <code>[]</code> (empty list) is falsy, Python evaluates the second operand <code>[1, 2, 3]</code>, which is truthy, and returns it. This is the \"default value\" pattern: <code>value or default</code>.</p> Practice Problem 4: Logical Operators <p>What's the difference between <code>==</code> and <code>is</code> when comparing to <code>True</code>?</p> Answer <ul> <li><code>==</code> checks for equality (value comparison)</li> <li><code>is</code> checks for identity (same object in memory)</li> </ul> <pre><code>x = 1\nprint(x == True)   # True \u2014 1 equals True in value\nprint(x is True)   # False \u2014 1 is not the same object as True\n\ny = True\nprint(y == True)   # True \u2014 obviously equal\nprint(y is True)   # True \u2014 same object\n</code></pre> <p>For boolean checks, use <code>if x:</code> (truthiness) rather than <code>if x == True:</code> or <code>if x is True:</code> unless you specifically need to distinguish <code>True</code> from other truthy values.</p>"},{"location":"basics/data_types/booleans/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Values Only <code>True</code> and <code>False</code> (capitalized!) Comparison operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> return booleans Logical operators <code>and</code>, <code>or</code>, <code>not</code> \u2014 can be combined Falsy values <code>False</code>, <code>None</code>, <code>0</code>, <code>0.0</code>, <code>\"\"</code>, <code>[]</code>, <code>{}</code>, <code>()</code> Truthy values Everything else Short-circuit <code>and</code>/<code>or</code> stop early when result is known Pythonic style Use <code>if items:</code> not <code>if len(items) &gt; 0:</code>"},{"location":"basics/data_types/booleans/#further-reading","title":"Further Reading","text":"<ul> <li>Python Boolean Operations Documentation - Official reference for <code>and</code>, <code>or</code>, <code>not</code></li> <li>Truth Value Testing - Complete list of falsy values and truthiness rules</li> <li>PEP 8 \u2013 Style Guide for Python Code - Boolean comparison best practices</li> <li>Computational Thinking - Understanding logical reasoning in programming</li> <li>Python Operators - Standard operators including comparison and boolean operators</li> </ul>"},{"location":"basics/data_types/booleans/#video-summary","title":"Video Summary","text":"<p>Booleans are deceptively simple\u2014just <code>True</code> and <code>False</code>\u2014yet they're the foundation of every decision your program makes. Master comparison operators, logical combinations, and truthiness, and you control the flow of execution. Understand short-circuit evaluation, and you write safer, more efficient code.</p> <p>Every <code>if</code> statement, every loop condition, every filter operation relies on boolean logic. The elegance of Python's truthiness (checking <code>if items:</code> instead of <code>if len(items) &gt; 0:</code>) reflects the language's philosophy: explicit is better than implicit, but simple is better than complex. Booleans embody both principles\u2014simple in concept, powerful in practice.</p>"},{"location":"basics/data_types/floats/","title":"Floats","text":"<p>While integers (whole numbers) are well-suited for many tasks, there are situations where precision beyond whole numbers is required. Enter the <code>float</code>. \ud83c\udfaf A <code>float</code>, short for \"floating-point number,\" is a numeric data type in Python that represents real numbers, including those with decimal points. Unlike integers (represented in Python as an <code>int</code>), which deal only with whole numbers, a <code>float</code> can handle values that have fractional components. For example, the mathematical constant <code>pi</code>, often approximated as 3.14, is a classic example of a <code>float</code> in Python. Consider the following examples:</p> Floating Point Numbers<pre><code>pi = 3.14\nprice = 10.99\ntemperature = 21.05\n</code></pre> <p>Floats are essential because they enable you to work with a wide range of data, especially in scientific, engineering, and financial applications. Whether dealing with temperature measurements, currency values, or mathematical constants, floats provide the flexibility to handle real-world data with fractional components.</p> <p>Precision Alert</p> <p>Floats are approximations, not exact values. This is crucial to understand before you go any further. See The Precision Problem below \u2014 it will save you hours of debugging headaches.</p>"},{"location":"basics/data_types/floats/#when-to-use-floats","title":"When to Use Floats","text":"<p>It\u2019s important to note that a <code>float</code> offers precision, but come at a cost \u2014 they occupy more memory (RAM) than integers. Therefore, it\u2019s advisable to use floats only when necessary. If your calculations involve whole numbers, it\u2019s more efficient to use integers. However, modern computers typically have ample RAM, making the memory overhead of floats less of a concern than in the past.</p> Sample Use Cases for Floats<pre><code>temperature = 21.05  # A float for temperature\nnumber_of_items = 5  # An integer for quantity\n</code></pre>"},{"location":"basics/data_types/floats/#use-cases-for-floats","title":"Use Cases for Floats","text":"<p>Floats find their applications in a wide array of scenarios. Here are a few everyday use cases where floats shine:</p> <ul> <li>Financial Calculations: Floats are ideal for handling financial data, such as calculating   interest rates, stock prices, or the exact cost of that fancy espresso machine you've been eyeing. \u2615</li> <li>Scientific Research: Scientists use floats to represent experimental data, physical   measurements, and mathematical constants like pi, e, or the gravitational constant.</li> <li>Engineering: Engineers use floats for precise calculations in structural analysis,   fluid dynamics, and electrical circuit design.</li> <li>Geospatial Data: When working with geographic coordinates or GPS data, floats are essential   for accurately representing latitude and longitude.</li> <li>Temperature and Weather: Floats store temperature values, making them suitable for weather forecasting and climate modelling.</li> </ul>"},{"location":"basics/data_types/floats/#using-floats","title":"Using Floats","text":"<p>In Python, performing arithmetic operations with floats is straightforward. If any mathematical operation involves a float, the result will also be a float. For example, multiplying an integer by a float yields a float result:</p> Arithmetic with Floats<pre><code>number_of_items = 5       # Integer\nprice = 10.99             # Float\ntotal_price = number_of_items * price  # Result is a float\nprint(total_price)\n</code></pre> <p>Results in:</p> <pre><code>54.95\n</code></pre>"},{"location":"basics/data_types/floats/#the-precision-problem-why-01-02-03","title":"The Precision Problem: Why 0.1 + 0.2 \u2260 0.3","text":"<p>Here's the moment that breaks every new programmer's brain. Try this in Python:</p> The Classic Gotcha<pre><code>result = 0.1 + 0.2\nprint(result)\nprint(result == 0.3)\n</code></pre> <p>Returns:</p> <pre><code>0.30000000000000004\nFalse\n</code></pre> <p>Wait, what? \ud83e\udd2f</p> <p>This isn't a Python bug \u2014 it's how all computers store decimal numbers. Floats are stored in binary (base-2), and just like 1/3 can't be exactly represented in decimal (0.333...), many simple decimals can't be exactly represented in binary. The number 0.1 in binary is actually an infinitely repeating fraction, so the computer stores the closest approximation it can fit.</p>"},{"location":"basics/data_types/floats/#why-this-matters","title":"Why This Matters","text":"<p>This isn't just a curiosity \u2014 it can cause real bugs:</p> A Bug Waiting to Happen<pre><code># Imagine this is checking if a bank balance is zero\nbalance = 0.1 + 0.1 + 0.1 - 0.3\n\nif balance == 0:\n    print(\"Account empty\")\nelse:\n    print(f\"Balance remaining: {balance}\")  # This runs!\n</code></pre> <p>Returns:</p> <pre><code>Balance remaining: 5.551115123125783e-17\n</code></pre> <p>Your \"zero\" balance is actually 0.00000000000000005551... Not exactly what you'd want in a banking application. \ud83d\udcb8</p>"},{"location":"basics/data_types/floats/#how-to-handle-float-comparisons","title":"How to Handle Float Comparisons","text":"<p>Option 1: Use <code>round()</code> for display and simple comparisons</p> Using round()<pre><code>result = 0.1 + 0.2\nprint(round(result, 2))  # 0.3\nprint(round(result, 2) == 0.3)  # True\n</code></pre> <p>Option 2: Use <code>math.isclose()</code> for robust comparisons</p> Using math.isclose()<pre><code>import math\n\nresult = 0.1 + 0.2\nprint(math.isclose(result, 0.3))  # True\n\n# You can adjust the tolerance if needed\nprint(math.isclose(result, 0.3, rel_tol=1e-9))  # True\n</code></pre> <p>Option 3: Use <code>Decimal</code> for financial calculations</p> <p>When precision actually matters (money, scientific measurements), use the <code>decimal</code> module:</p> Using Decimal for Exact Math<pre><code>from decimal import Decimal\n\n# Create Decimals from strings, not floats!\nprice = Decimal(\"19.99\")\ntax_rate = Decimal(\"0.15\")\ntotal = price * (1 + tax_rate)\nprint(total)  # 22.9885 \u2014 exact!\n</code></pre> <p>Rule of Thumb</p> <ul> <li>Display to users: Use <code>round()</code></li> <li>Comparing floats: Use <code>math.isclose()</code></li> <li>Financial/precise calculations: Use <code>Decimal</code></li> <li>Scientific computing: Use NumPy (it handles precision more gracefully)</li> </ul>"},{"location":"basics/data_types/floats/#scientific-notation","title":"Scientific Notation","text":"<p>For very large or very small numbers, Python supports scientific notation using <code>e</code>:</p> Scientific Notation<pre><code>speed_of_light = 3e8       # 300,000,000 meters per second\nplanck_constant = 6.626e-34  # A very small number\n\nprint(speed_of_light)      # 300000000.0\nprint(planck_constant)     # 6.626e-34\n</code></pre> <p>The <code>e</code> means \"times 10 to the power of\" \u2014 so <code>3e8</code> is 3 \u00d7 10\u2078. This is much easier to read (and type) than <code>300000000.0</code>. Your fingers will thank you. \u2328\ufe0f</p>"},{"location":"basics/data_types/floats/#useful-float-functions","title":"Useful Float Functions","text":"<p>Python provides several built-in functions for working with floats:</p> Handy Float Functions<pre><code>import math\n\n# Rounding\nprint(round(3.14159, 2))    # 3.14 \u2014 round to 2 decimal places\nprint(round(2.5))           # 2 \u2014 Python uses \"banker's rounding\" (to nearest even)\nprint(round(3.5))           # 4\n\n# Absolute value\nprint(abs(-42.5))           # 42.5\n\n# Floor and ceiling\nprint(math.floor(3.7))      # 3 \u2014 round down\nprint(math.ceil(3.2))       # 4 \u2014 round up\n\n# Truncate (remove decimal part)\nprint(math.trunc(3.9))      # 3\nprint(math.trunc(-3.9))     # -3 (toward zero, not down)\n</code></pre> Banker's Rounding <p>Python's <code>round()</code> uses \"round half to even\" (banker's rounding). This means 2.5 rounds to 2, but 3.5 rounds to 4. This reduces bias when rounding lots of numbers. If you need traditional \"round half up\" behavior, you'll need to implement it yourself or use <code>Decimal</code>.</p>"},{"location":"basics/data_types/floats/#converting-to-and-from-floats","title":"Converting To and From Floats","text":"Type Conversion<pre><code># String to float\nprice = float(\"19.99\")\nprint(price)  # 19.99\n\n# Integer to float\nwhole_number = float(42)\nprint(whole_number)  # 42.0\n\n# Float to integer (truncates!)\nprint(int(3.9))   # 3 \u2014 decimal part is discarded\nprint(int(-3.9))  # -3\n\n# Check if something is a float\nprint(isinstance(3.14, float))  # True\nprint(isinstance(3, float))     # False\n</code></pre> <p>String Conversion</p> <p><code>float()</code> will raise a <code>ValueError</code> if the string isn't a valid number:</p> <pre><code>float(\"hello\")  # ValueError: could not convert string to float: 'hello'\n</code></pre>"},{"location":"basics/data_types/floats/#special-float-values","title":"Special Float Values","text":"<p>Python floats can represent some special mathematical concepts:</p> Special Values<pre><code>import math\n\n# Infinity\npositive_inf = float('inf')\nnegative_inf = float('-inf')\nprint(positive_inf &gt; 1000000000)  # True \u2014 infinity is bigger than any number\nprint(1 / positive_inf)           # 0.0\n\n# Not a Number (NaN)\nnot_a_number = float('nan')\nprint(not_a_number == not_a_number)  # False! NaN is not equal to anything, even itself\nprint(math.isnan(not_a_number))      # True \u2014 use this to check for NaN\n</code></pre> <p>These come up when doing math that would otherwise cause errors, like dividing by zero in some contexts or taking the square root of a negative number.</p>"},{"location":"basics/data_types/floats/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Precision Floats are approximations \u2014 <code>0.1 + 0.2 != 0.3</code> Comparisons Use <code>math.isclose()</code>, not <code>==</code> Money Use <code>Decimal</code>, not <code>float</code> Scientific notation <code>3e8</code> = 3 \u00d7 10\u2078 Rounding Python uses banker's rounding (round half to even) Special values <code>float('inf')</code>, <code>float('-inf')</code>, <code>float('nan')</code> exist"},{"location":"basics/data_types/ints/","title":"Integers","text":"<p>Count users in a database. Calculate pixels on a screen. Track inventory quantities. Process financial transactions. Loop exactly 100 times. Index into the 42nd element of a list.</p> <p>Every one of these tasks requires whole numbers\u2014integers. No fractions, no decimals, just precise counting and calculation. Integers are Python's workhorse numeric type, appearing in nearly every program you write.</p>"},{"location":"basics/data_types/ints/#what-is-an-integer","title":"What is an Integer?","text":"<p>Integers (<code>int</code> type) represent whole numbers\u2014positive, negative, or zero:</p> Creating Integers<pre><code>count = 42                # (1)!\ntemperature = -15         # (2)!\nbalance = 0\nlarge_number = 1_000_000  # (3)!\n</code></pre> <ol> <li>Positive integers\u2014the most common case</li> <li>Negative integers work identically</li> <li>Underscores improve readability for large numbers (Python 3.6+)\u2014<code>1_000_000</code> is the same as <code>1000000</code></li> </ol> <p>Unlike many programming languages where integers have size limits (32-bit, 64-bit), Python integers can be arbitrarily large\u2014limited only by available memory.</p>"},{"location":"basics/data_types/ints/#why-integers-matter","title":"Why Integers Matter","text":"<p>Integers solve fundamental programming problems:</p> <ul> <li>Counting: Users, iterations, items in a collection</li> <li>Indexing: Accessing elements in sequences (lists, strings)</li> <li>File I/O: Byte offsets, line numbers, file sizes</li> <li>Game development: Scores, health points, coordinates</li> <li>Web applications: Pagination (page 5 of 100), user IDs</li> <li>Data processing: Row counts, batch sizes</li> </ul> <p>Every time you use <code>range()</code>, index a list, or count occurrences, you're working with integers. They're the foundation of computational thinking\u2014the discrete, step-by-step logic that computers excel at.</p>"},{"location":"basics/data_types/ints/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Calculate total price from quantity and unit cost. Determine grid dimensions. Compute elapsed time from timestamps. Scale image coordinates. Integers power these calculations.</p>"},{"location":"basics/data_types/ints/#basic-operators","title":"Basic Operators","text":"Basic Arithmetic<pre><code>a = 10\nb = 3\n\nprint(a + b)   # (1)!\nprint(a - b)   # (2)!\nprint(a * b)   # (3)!\nprint(a ** b)  # (4)!\n</code></pre> <ol> <li>Addition: <code>13</code>\u2014combining quantities</li> <li>Subtraction: <code>7</code>\u2014finding differences, remainders</li> <li>Multiplication: <code>30</code>\u2014scaling values, calculating areas</li> <li>Exponentiation: <code>1000</code> (10\u00b3)\u2014growth rates, compound calculations</li> </ol>"},{"location":"basics/data_types/ints/#division-three-types-for-different-needs","title":"Division: Three Types for Different Needs","text":"<p>Division is where integers reveal their nuances. Python provides three division operators because different problems require different behaviors:</p> Division Types<pre><code>a = 17\nb = 5\n\nprint(a / b)   # (1)!\nprint(a // b)  # (2)!\nprint(a % b)   # (3)!\n</code></pre> <ol> <li>True division: <code>3.4</code>\u2014always returns a float, even if the result is a whole number</li> <li>Floor division: <code>3</code>\u2014rounds down to the nearest integer (useful for pagination, chunking)</li> <li>Modulo: <code>2</code>\u2014returns the remainder after division (essential for cycling, even/odd checks)</li> </ol> <p>Why three operators? Different problems need different behaviors:</p> Operator Name When to Use Example Use Case <code>/</code> True division Need decimal precision Calculating averages, percentages <code>//</code> Floor division Need integer result, round down Pagination (items per page), splitting into chunks <code>%</code> Modulo Need remainder Checking even/odd, cycling through lists, time calculations <p>True Division Always Returns a Float</p> <p>Even if the division is \"clean,\" <code>/</code> returns a float:</p> <pre><code>print(10 / 2)   # 5.0, not 5\nprint(type(10 / 2))  # &lt;class 'float'&gt;\n</code></pre> <p>If you need an integer result, use <code>//</code> or wrap in <code>int()</code>.</p>"},{"location":"basics/data_types/ints/#floor-division-with-negative-numbers","title":"Floor Division with Negative Numbers","text":"<p>Floor division always rounds toward negative infinity\u2014not toward zero. This catches programmers familiar with other languages:</p> Floor Division with Negatives<pre><code>print(17 // 5)    # (1)!\nprint(-17 // 5)   # (2)!\nprint(17 // -5)   # (3)!\n</code></pre> <ol> <li>Returns <code>3</code>\u2014rounds down from 3.4 as expected</li> <li>Returns <code>-4</code>\u2014rounds down from -3.4 (toward negative infinity, not toward zero!)</li> <li>Returns <code>-4</code>\u2014same behavior with negative divisor</li> </ol> <p>This is mathematically consistent but surprises those expecting truncation toward zero.</p>"},{"location":"basics/data_types/ints/#the-modulo-operator-in-real-use","title":"The Modulo Operator in Real Use","text":"<p>Check if a number is even or odd. Cycle through array indices. Convert 24-hour to 12-hour time. Implement round-robin task assignment. Modulo powers all these patterns:</p> Practical Modulo Uses<pre><code># Check if a number is even or odd\nnumber = 42\nif number % 2 == 0:  # (1)!\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n\n# Wrap around (like a clock)\nhour = 14\nprint(hour % 12)  # (2)!\n\n# Check divisibility\nif 100 % 25 == 0:  # (3)!\n    print(\"100 is divisible by 25\")\n\n# Cycle through a list\ncolors = [\"red\", \"green\", \"blue\"]\nfor i in range(10):  # (4)!\n    print(colors[i % len(colors)])  # (5)!\n</code></pre> <ol> <li>Even/odd check\u2014if statement tests if remainder is 0 when divided by 2</li> <li>Returns <code>2</code>\u2014converts 14:00 (2 PM) to 12-hour format</li> <li>Divisibility test\u2014remainder of 0 means evenly divisible</li> <li>For loop with range\u2014common pattern for iteration</li> <li>Cycles through colors: <code>i % 3</code> wraps indices 0,1,2,0,1,2... regardless of how large <code>i</code> gets</li> </ol>"},{"location":"basics/data_types/ints/#operator-precedence","title":"Operator Precedence","text":"<p>Calculate a discount with tax. Compute compound interest. Convert units with multiple steps. Complex formulas fail when operators execute in the wrong order. Understanding precedence prevents subtle bugs in mathematical expressions:</p> Order of Operations<pre><code>result = 2 + 3 * 4      # (1)!\nresult = (2 + 3) * 4    # (2)!\nresult = 2 ** 3 ** 2    # (3)!\nresult = 10 - 3 - 2     # (4)!\n</code></pre> <ol> <li>Returns <code>14</code>, not 20\u2014multiplication happens before addition</li> <li>Returns <code>20</code>\u2014parentheses override precedence</li> <li>Returns <code>512</code>\u2014exponentiation is right-to-left: 3\u00b2 = 9, then 2\u2079 = 512</li> <li>Returns <code>5</code>\u2014subtraction is left-to-right: (10 - 3) - 2 = 7 - 2 = 5</li> </ol> Priority Operators Description 1 (highest) <code>**</code> Exponentiation 2 <code>+x</code>, <code>-x</code> Unary plus/minus 3 <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code> Multiplication, division, modulo 4 (lowest) <code>+</code>, <code>-</code> Addition, subtraction <p>When in Doubt, Use Parentheses</p> <p>Even if you know the precedence rules, parentheses make your intent clear:</p> <pre><code># Confusing\nresult = a + b * c / d - e ** f\n\n# Clear\nresult = a + ((b * c) / d) - (e ** f)\n</code></pre>"},{"location":"basics/data_types/ints/#useful-integer-functions","title":"Useful Integer Functions","text":"<p>Find the largest score in a game. Calculate total sales from a list. Get the distance between two points regardless of direction. These common operations appear in nearly every program\u2014Python provides built-in functions so you don't reinvent them:</p> Handy Integer Functions<pre><code># Absolute value\nprint(abs(-42))      # (1)!\nprint(abs(42))\n\n# Power (alternative to **)\nprint(pow(2, 10))    # (2)!\nprint(pow(2, 10, 100))  # (3)!\n\n# Min and max\nprint(min(5, 3, 8, 1))  # (4)!\nprint(max(5, 3, 8, 1))\n\n# Sum of an iterable\nnumbers = [1, 2, 3, 4, 5]\nprint(sum(numbers))  # (5)!\n\n# divmod \u2014 returns both quotient and remainder\nquotient, remainder = divmod(17, 5)  # (6)!\nprint(f\"17 \u00f7 5 = {quotient} remainder {remainder}\")\n</code></pre> <ol> <li>Returns <code>42</code>\u2014<code>abs()</code> converts negative to positive (useful for distances, differences)</li> <li>Returns <code>1024</code>\u2014<code>pow(x, y)</code> is equivalent to <code>x ** y</code></li> <li>Returns <code>24</code>\u2014three-argument form: <code>(2\u00b9\u2070) % 100</code> (efficient for cryptography, large numbers)</li> <li>Returns <code>1</code>\u2014finds minimum value (works with any number of arguments or an iterable)</li> <li>Returns <code>15</code>\u2014adds all values in a list</li> <li>Returns both quotient (3) and remainder (2) in one operation\u2014more efficient than using <code>//</code> and <code>%</code> separately</li> </ol>"},{"location":"basics/data_types/ints/#number-systems","title":"Number Systems","text":"<p>Parse network packets. Set file permissions on Unix. Define colors for web design. Work with memory addresses. Process bit flags. Different number bases aren't academic\u2014they're practical tools for systems programming, web development, and data processing.</p>"},{"location":"basics/data_types/ints/#why-number-bases-matter","title":"Why Number Bases Matter","text":"<ul> <li>Binary (base 2): Bit manipulation, flags, permissions, low-level protocols</li> <li>Hexadecimal (base 16): Colors (<code>#FF5733</code>), memory addresses, MAC addresses, hashing</li> <li>Octal (base 8): Unix file permissions (<code>chmod 755</code>)</li> </ul> <p>Python lets you write integers in any of these bases:</p> Different Number Bases<pre><code>decimal = 255        # (1)!\nbinary = 0b11111111  # (2)!\noctal = 0o377        # (3)!\nhexadecimal = 0xFF   # (4)!\n\n# They're all the same number!\nprint(decimal == binary == octal == hexadecimal)  # (5)!\nprint(decimal, binary, octal, hexadecimal)\n</code></pre> <ol> <li>Base 10 (decimal)\u2014the default, what we use daily</li> <li>Base 2 (binary)\u2014prefix <code>0b</code>\u2014useful for bit operations</li> <li>Base 8 (octal)\u2014prefix <code>0o</code>\u2014used in Unix permissions</li> <li>Base 16 (hexadecimal)\u2014prefix <code>0x</code>\u2014common in web colors, memory addresses</li> <li>Returns <code>True</code>\u2014all represent 255, just in different notations</li> </ol>"},{"location":"basics/data_types/ints/#converting-between-bases","title":"Converting Between Bases","text":"Base Conversion<pre><code>number = 255\n\n# Convert to string representation in different bases\nprint(bin(number))   # (1)!\nprint(oct(number))   # (2)!\nprint(hex(number))   # (3)!\n\n# Convert string back to int (specify the base)\nprint(int('11111111', 2))   # (4)!\nprint(int('377', 8))\nprint(int('FF', 16))\nprint(int('ff', 16))        # (5)!\n</code></pre> <ol> <li>Returns <code>'0b11111111'</code>\u2014binary string representation</li> <li>Returns <code>'0o377'</code>\u2014octal string representation</li> <li>Returns <code>'0xff'</code>\u2014hexadecimal string representation</li> <li>Parse binary string to integer by specifying base 2 as second argument</li> <li>Hexadecimal parsing is case-insensitive\u2014<code>'FF'</code> and <code>'ff'</code> both work</li> </ol> Real-World Number Base Examples <p>Web development\u2014RGB colors: <pre><code># RGB color as hex\nred = 0xFF\ngreen = 0x57\nblue = 0x33\nprint(f\"#{red:02X}{green:02X}{blue:02X}\")  # #FF5733\n</code></pre></p> <p>Systems programming\u2014Unix permissions: <pre><code># chmod 755 in Python\nrwx_owner = 0o700   # Read, write, execute for owner\nrx_group = 0o050    # Read, execute for group\nrx_other = 0o005    # Read, execute for others\npermissions = rwx_owner | rx_group | rx_other\nprint(oct(permissions))  # 0o755\n</code></pre></p>"},{"location":"basics/data_types/ints/#pythons-unlimited-integer-size","title":"Python's Unlimited Integer Size","text":"<p>Calculate factorial of 100. Process credit card numbers. Work with cryptographic keys. Handle astronomical calculations. Generate large prime numbers. In other languages, these tasks hit integer overflow\u2014values wrap around or crash. Python just works:</p> Arbitrarily Large Integers<pre><code># This is perfectly valid Python\nhuge = 10 ** 100  # (1)!\nprint(huge)\n\n# Calculate factorial of 100\nimport math\nprint(math.factorial(100))  # (2)!\n</code></pre> <ol> <li>A googol (10\u00b9\u2070\u2070)\u2014100 digits long! Python handles this without overflow</li> <li>Returns a 158-digit number\u2014no special \"big integer\" library needed</li> </ol> <p>No Integer Overflow</p> <p>Languages like C or Java use fixed-size integers (32-bit, 64-bit) that overflow when values get too large. Python automatically switches to arbitrary-precision arithmetic\u2014you'll never see integer overflow, just potentially slower calculations with very large numbers.</p>"},{"location":"basics/data_types/ints/#converting-to-and-from-integers","title":"Converting To and From Integers","text":"<p>Parse user input from a form. Read numeric data from CSV files. Round measurements down to whole units. Display counts in messages. Data arrives in various types\u2014strings from files, floats from calculations, booleans from logic. Converting between types is constant in real programs:</p> Type Conversion<pre><code># String to integer\nage = int(\"25\")  # (1)!\nprint(age + 1)\n\n# Float to integer (truncates toward zero!)\nprint(int(3.9))    # (2)!\nprint(int(-3.9))\n\n# Boolean to integer\nprint(int(True))   # (3)!\nprint(int(False))\n\n# Integer to string\ncount = 42\nmessage = f\"The answer is {count}\"  # (4)!\nprint(message)\n\n# Check if something is an integer\nprint(isinstance(42, int))     # (5)!\nprint(isinstance(42.0, int))\n</code></pre> <ol> <li>Parse string to integer\u2014essential for processing user input, file data</li> <li>Returns <code>3</code> (not 4!)\u2014<code>int()</code> truncates toward zero, doesn't round (see floats for precision)</li> <li>Returns <code>1</code>\u2014booleans convert to 0 and 1 (useful in calculations)</li> <li>F-strings handle conversion automatically\u2014cleaner than <code>str(count)</code> concatenation</li> <li>Returns <code>True</code>\u2014<code>isinstance()</code> checks type (note: <code>42.0</code> is float, not int)</li> </ol> <p>int() Truncates, Not Rounds</p> <p><code>int()</code> always truncates toward zero\u2014different from <code>round()</code> or floor division:</p> <pre><code>print(int(3.9))    # 3 (truncated)\nprint(round(3.9))  # 4 (rounded)\nprint(int(-3.9))   # -3 (truncated toward zero)\nprint(-3.9 // 1)   # -4.0 (floor division toward negative infinity)\n</code></pre>"},{"location":"basics/data_types/ints/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Division Types <p>What's the difference between <code>17 / 5</code>, <code>17 // 5</code>, and <code>17 % 5</code>?</p> Answer <pre><code>print(17 / 5)   # 3.4 - true division (float)\nprint(17 // 5)  # 3 - floor division (rounds down)\nprint(17 % 5)   # 2 - modulo (remainder)\n</code></pre> <ul> <li><code>/</code> gives the exact quotient as a float</li> <li><code>//</code> gives the quotient rounded down to an integer</li> <li><code>%</code> gives the remainder after division</li> </ul> Practice Problem 2: Modulo for Even/Odd <p>Write code to determine if a number stored in variable <code>n</code> is even or odd using the modulo operator.</p> Answer <pre><code>n = 42\nif n % 2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n</code></pre> <p>Any even number divided by 2 has remainder 0. Odd numbers have remainder 1.</p> Practice Problem 3: Number Bases <p>What decimal number do these represent: <code>0b1010</code>, <code>0o12</code>, <code>0xA</code>?</p> Answer <p>All three represent the decimal number <code>10</code>:</p> <pre><code>print(0b1010)  # 10 (binary: 1\u00d78 + 0\u00d74 + 1\u00d72 + 0\u00d71)\nprint(0o12)    # 10 (octal: 1\u00d78 + 2\u00d71)\nprint(0xA)     # 10 (hex: A = 10)\n</code></pre> <p>Python automatically converts all number literals to decimal for display.</p> Practice Problem 4: Floor Division Trap <p>What does <code>print(-17 // 5)</code> output, and why might it be surprising?</p> Answer <p>It outputs <code>-4</code>, not <code>-3</code>.</p> <pre><code>print(-17 / 5)   # -3.4\nprint(-17 // 5)  # -4 (rounds DOWN toward negative infinity)\nprint(int(-17 / 5))  # -3 (truncates toward zero)\n</code></pre> <p>Floor division (<code>//</code>) always rounds toward negative infinity, so -3.4 rounds down to -4. This differs from truncation toward zero, which would give -3.</p>"},{"location":"basics/data_types/ints/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember Division types <code>/</code> (float), <code>//</code> (floor), <code>%</code> (modulo) True division Always returns a float, even for <code>10 / 2</code> Floor division Rounds toward negative infinity, not zero Modulo Great for even/odd, cycling, divisibility Precedence <code>**</code> \u2192 <code>* / // %</code> \u2192 <code>+ -</code> (use parentheses!) Number bases <code>0b</code> (binary), <code>0o</code> (octal), <code>0x</code> (hex) No overflow Python integers can be arbitrarily large int() truncates Toward zero, not rounding"},{"location":"basics/data_types/ints/#further-reading","title":"Further Reading","text":"<ul> <li>Python Integer Documentation - Official reference for integer operations</li> <li>PEP 237 \u2013 Unifying Long Integers and Integers - How Python removed integer overflow</li> <li>Bitwise Operations - Advanced integer operations for low-level programming</li> <li>Python's Data Model - Deep dive into how integers work internally</li> <li>Computational Thinking - Problem-solving patterns using discrete mathematics</li> <li>What is Computer Science? - Understanding how computers process discrete values</li> </ul> <p>Integers are the foundation of computational logic. From counting loop iterations to indexing arrays, from checking divisibility to converting between number systems, integers power the discrete mathematics that computers excel at.</p> <p>Python's integer implementation removes the complexity found in other languages\u2014no overflow errors, no separate \"long\" types, automatic precision scaling. This lets you focus on solving problems rather than managing numeric representation.</p> <p>Master integers, and you master the building blocks of algorithmic thinking.</p>"},{"location":"basics/data_types/none/","title":"None","text":"<p>Every programming language needs a way to represent \"nothing.\" In Python, that's <code>None</code>. \ud83d\udd73\ufe0f</p> <p><code>None</code> is Python's null value \u2014 it represents the absence of a value, rather than a value of zero, empty, or false. It's a singleton, meaning there's only ever one <code>None</code> object in memory, and it's used everywhere: function returns, optional parameters, placeholder values, and more.</p> The None Type<pre><code>nothing = None\nprint(nothing)        # None\nprint(type(nothing))  # &lt;class 'NoneType'&gt;\n</code></pre> <p>None is Not...</p> <p><code>None</code> is not the same as:</p> <ul> <li><code>0</code> (that's an integer with a value)</li> <li><code>\"\"</code> (that's an empty string \u2014 still a string)</li> <li><code>[]</code> (that's an empty list \u2014 still a list)</li> <li><code>False</code> (that's a boolean with a value)</li> </ul> <p><code>None</code> means \"no value at all.\"</p>"},{"location":"basics/data_types/none/#when-youll-encounter-none","title":"When You'll Encounter None","text":""},{"location":"basics/data_types/none/#functions-without-a-return-value","title":"Functions Without a Return Value","text":"<p>If a function doesn't explicitly return something, it returns <code>None</code>:</p> Implicit None Return<pre><code>def greet(name):\n    print(f\"Hello, {name}!\")\n    # No return statement\n\nresult = greet(\"Alice\")  # Prints \"Hello, Alice!\"\nprint(result)            # None\nprint(result is None)    # True\n</code></pre> <p>This catches many beginners off guard. If you forget to return a value, your function silently returns <code>None</code>. \ud83e\udd2b</p> The Forgotten Return<pre><code>def add(a, b):\n    total = a + b\n    # Oops! Forgot to return total\n\nresult = add(2, 3)\nprint(result)  # None \u2014 not 5!\n</code></pre>"},{"location":"basics/data_types/none/#optional-parameters","title":"Optional Parameters","text":"<p><code>None</code> is commonly used as a default for optional parameters:</p> None as Default Parameter<pre><code>def connect(host, port=None):\n    if port is None:\n        port = 8080  # Use default\n    print(f\"Connecting to {host}:{port}\")\n\nconnect(\"localhost\")        # Connecting to localhost:8080\nconnect(\"localhost\", 3000)  # Connecting to localhost:3000\n</code></pre> <p>Why Not Just Use the Default Directly?</p> <p>You might wonder why not write <code>port=8080</code> directly. Using <code>None</code> is useful when:</p> <ul> <li>The default depends on other parameters or runtime conditions</li> <li>You need to distinguish between \"not provided\" and \"explicitly set to the default\"</li> <li>The default is mutable (like a list) \u2014 never use mutable defaults!</li> </ul> <pre><code># DANGER: Mutable default argument\ndef add_item(item, items=[]):  # DON'T DO THIS\n    items.append(item)\n    return items\n\n# SAFE: Use None instead\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n</code></pre>"},{"location":"basics/data_types/none/#dictionary-and-attribute-access","title":"Dictionary and Attribute Access","text":"<p>Many methods return <code>None</code> when a key or attribute doesn't exist:</p> None from Missing Keys<pre><code>user = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n\n# .get() returns None for missing keys (instead of raising KeyError)\nphone = user.get(\"phone\")\nprint(phone)  # None\n\n# You can provide a default\nphone = user.get(\"phone\", \"Not provided\")\nprint(phone)  # \"Not provided\"\n</code></pre>"},{"location":"basics/data_types/none/#representing-not-yet-set","title":"Representing \"Not Yet Set\"","text":"<p><code>None</code> is useful as a placeholder for values that will be set later:</p> Placeholder Values<pre><code>class User:\n    def __init__(self, username):\n        self.username = username\n        self.email = None      # Will be set later\n        self.verified = None   # Unknown until checked\n\nuser = User(\"bob\")\nprint(user.email)  # None\n\n# Later...\nuser.email = \"bob@example.com\"\n</code></pre>"},{"location":"basics/data_types/none/#checking-for-none-is-vs","title":"Checking for None: <code>is</code> vs <code>==</code>","text":"<p>This is important: always use <code>is None</code>, not <code>== None</code>.</p> is None vs == None<pre><code>value = None\n\n# CORRECT \u2014 use 'is'\nif value is None:\n    print(\"Value is None\")\n\n# ALSO CORRECT \u2014 use 'is not'\nif value is not None:\n    print(\"Value has been set\")\n\n# AVOID \u2014 technically works but not idiomatic\nif value == None:\n    print(\"This works but don't do it\")\n</code></pre>"},{"location":"basics/data_types/none/#why-is-instead-of","title":"Why <code>is</code> Instead of <code>==</code>?","text":"<ol> <li><code>is</code> checks identity \u2014 is this the exact same object?</li> <li><code>==</code> checks equality \u2014 do these objects have the same value?</li> </ol> <p>Since there's only one <code>None</code> object, <code>is</code> is both faster and more explicit about your intent. It also avoids edge cases where a custom class might override <code>__eq__</code>:</p> The == Gotcha<pre><code>class Sneaky:\n    def __eq__(self, other):\n        return True  # Claims to equal everything!\n\nsneaky = Sneaky()\nprint(sneaky == None)   # True \u2014 but sneaky isn't None!\nprint(sneaky is None)   # False \u2014 correct answer\n</code></pre> <p>Linters Will Complain</p> <p>Tools like <code>flake8</code> and <code>pylint</code> will flag <code>== None</code> as a code smell. Use <code>is None</code> to keep your code clean and your linters happy.</p>"},{"location":"basics/data_types/none/#none-and-truthiness","title":"None and Truthiness","text":"<p><code>None</code> is falsy \u2014 it evaluates to <code>False</code> in a boolean context:</p> None is Falsy<pre><code>if not None:\n    print(\"None is falsy!\")  # This prints\n\n# Same as\nif None:\n    print(\"This won't print\")\nelse:\n    print(\"None is falsy!\")  # This prints\n</code></pre>"},{"location":"basics/data_types/none/#the-truthiness-trap","title":"The Truthiness Trap","text":"<p>Because <code>None</code> is falsy, you need to be careful when checking for it:</p> Distinguishing None from Other Falsy Values<pre><code>def process(value):\n    # This treats None, 0, \"\", and [] the same!\n    if not value:\n        print(\"No value provided\")\n        return\n\n    print(f\"Processing: {value}\")\n\nprocess(None)  # \"No value provided\" \u2014 correct\nprocess(0)     # \"No value provided\" \u2014 but 0 IS a value!\nprocess(\"\")    # \"No value provided\" \u2014 but \"\" might be intentional!\n</code></pre> <p>If you need to specifically check for <code>None</code> while allowing other falsy values:</p> Explicit None Check<pre><code>def process(value):\n    if value is None:\n        print(\"No value provided\")\n        return\n\n    print(f\"Processing: {value}\")\n\nprocess(None)  # \"No value provided\"\nprocess(0)     # \"Processing: 0\" \u2014 zero is processed!\nprocess(\"\")    # \"Processing: \" \u2014 empty string is processed!\n</code></pre>"},{"location":"basics/data_types/none/#common-patterns","title":"Common Patterns","text":""},{"location":"basics/data_types/none/#guard-clauses","title":"Guard Clauses","text":"<p>Return early if a required value is <code>None</code>:</p> Guard Clause Pattern<pre><code>def send_email(user):\n    if user is None:\n        return  # Can't send to nobody\n\n    if user.email is None:\n        print(f\"No email for {user.name}\")\n        return\n\n    # Now we know user and user.email exist\n    actually_send_email(user.email)\n</code></pre>"},{"location":"basics/data_types/none/#the-or-default-with-caution","title":"The <code>or</code> Default (With Caution)","text":"<p>You can use <code>or</code> to provide a fallback, but be aware of the truthiness trap:</p> The or Pattern<pre><code># Works for None\nname = None\ndisplay_name = name or \"Anonymous\"\nprint(display_name)  # \"Anonymous\"\n\n# But watch out for other falsy values\ncount = 0\ndisplay_count = count or 10\nprint(display_count)  # 10 \u2014 oops! We wanted 0!\n\n# Safer version for when 0/\"\"/[] might be valid\ndisplay_count = count if count is not None else 10\nprint(display_count)  # 0 \u2014 correct!\n</code></pre>"},{"location":"basics/data_types/none/#optional-chaining-python-38","title":"Optional Chaining (Python 3.8+)","text":"<p>The walrus operator can help with None checks:</p> Walrus Operator with None<pre><code># Instead of:\nresult = get_user()\nif result is not None:\n    process(result)\n\n# You can write:\nif (result := get_user()) is not None:\n    process(result)\n</code></pre>"},{"location":"basics/data_types/none/#type-hints-with-none","title":"Type Hints with None","text":"<p>When using type hints, <code>None</code> has its own type annotation:</p> Type Hints with None<pre><code>from typing import Optional\n\n# A function that might return None\ndef find_user(user_id: int) -&gt; Optional[str]:\n    \"\"\"Returns username or None if not found.\"\"\"\n    users = {1: \"alice\", 2: \"bob\"}\n    return users.get(user_id)\n\n# Parameter that could be None\ndef greet(name: Optional[str] = None) -&gt; str:\n    if name is None:\n        return \"Hello, stranger!\"\n    return f\"Hello, {name}!\"\n\n# Python 3.10+ allows the shorter syntax\ndef greet(name: str | None = None) -&gt; str:\n    ...\n</code></pre>"},{"location":"basics/data_types/none/#key-takeaways","title":"Key Takeaways","text":"Concept What to Remember What it is The absence of a value \u2014 not zero, not empty, not false Singleton There's only one <code>None</code> object in Python Check with <code>is</code> Always <code>is None</code> or <code>is not None</code>, never <code>== None</code> Falsy <code>None</code> evaluates to <code>False</code> in boolean contexts Function returns Functions without <code>return</code> implicitly return <code>None</code> Default parameters Use <code>None</code> for optional params, especially with mutable types Type hint <code>Optional[X]</code> or <code>X | None</code> (Python 3.10+)"},{"location":"basics/data_types/strings/","title":"Strings","text":"<p>Every program you've ever used displays text. Error messages, user prompts, search results, social media posts, this very sentence\u2014all text, all represented as strings in the underlying code.</p> <p>Strings are Python's fundamental data type for representing text. They're immutable sequences of Unicode characters, meaning they can contain everything from English letters to emojis to Chinese characters. Whether you're processing user input, reading files, scraping websites, or formatting output, you'll work with strings constantly.</p> <p>Understanding strings deeply isn't optional for Python programmers\u2014it's essential.</p>"},{"location":"basics/data_types/strings/#what-is-a-string","title":"What is a String?","text":"<p>A string in Python is any text enclosed in single quotes (<code>'...'</code>), double quotes (<code>\"...\"</code>), or triple quotes (<code>'''...'''</code> or <code>\"\"\"...\"\"\"</code>):</p> Creating Strings<pre><code>name = \"Alice\"              # (1)!\nlocation = 'Halifax'        # (2)!\noccupation = \"Software Developer\"\nmultiline = \"\"\"This is a\nlonger string that spans\nmultiple lines.\"\"\"          # (3)!\n</code></pre> <ol> <li>Double quotes are most common for strings</li> <li>Single quotes work identically\u2014use whichever you prefer</li> <li>Triple quotes preserve line breaks and are useful for docstrings</li> </ol> <p>Python treats single and double quotes identically. The flexibility lets you embed one type of quote inside the other:</p> Quotes Within Strings<pre><code>message = \"He said, 'Python is great!'\"\npath = 'C:\\\\Users\\\\Alice\\\\Documents'  # (1)!\n</code></pre> <ol> <li>Backslash escapes special characters\u2014here it prevents the backslash from being interpreted as an escape sequence</li> </ol>"},{"location":"basics/data_types/strings/#why-strings-matter","title":"Why Strings Matter","text":"<p>Strings are the interface between your program and the world:</p> <ul> <li>User interaction: Every input from a user starts as a string</li> <li>File I/O: Reading and writing files means processing strings</li> <li>Web development: HTML, JSON, URLs\u2014all manipulated as strings</li> <li>Data processing: CSV files, log parsing, text analysis</li> <li>APIs: Most web APIs exchange data as JSON strings</li> </ul> <p>You can't avoid strings in Python. The question isn't whether you'll use them, but how well you understand them.</p>"},{"location":"basics/data_types/strings/#building-strings-with-f-strings","title":"Building Strings with F-Strings","text":"<p>When you need to combine text with variables, use f-strings (formatted string literals)\u2014Python's modern, preferred approach:</p> F-String Formatting<pre><code>name = \"Alice\"\nage = 30\nprint(f\"Hello, {name}! You are {age} years old.\")  # (1)!\n\n# F-strings support expressions\nprint(f\"Next year you'll be {age + 1}.\")  # (2)!\n\n# And formatting specifications\npi = 3.14159265\nprint(f\"Pi to 2 decimals: {pi:.2f}\")  # (3)!\n</code></pre> <ol> <li>Variables inside <code>{...}</code> are automatically converted to strings and embedded</li> <li>You can include any Python expression inside the braces</li> <li>Format specifiers control number formatting (<code>.2f</code> means 2 decimal places)</li> </ol> <p>F-strings are fast, readable, and powerful. They're the Pythonic way to build strings in modern Python (3.6+).</p> Other String Building Methods You Might See <p>Older Python code uses different approaches for combining strings:</p> <p>Concatenation with <code>+</code>: <pre><code>first_name = \"Albert\"\nlast_name = \"Einstein\"\nfull_name = first_name + \" \" + last_name  # Works, but verbose\n</code></pre></p> <p>The <code>.format()</code> method (pre-3.6): <pre><code>message = \"Hello, {}! You are {} years old.\".format(name, age)\n</code></pre></p> <p>Percent formatting (very old): <pre><code>message = \"Hello, %s! You are %d years old.\" % (name, age)\n</code></pre></p> <p>All three work, but f-strings are clearer, faster, and preferred in modern Python. Use f-strings unless you have a specific reason not to.</p>"},{"location":"basics/data_types/strings/#string-indexing-and-length","title":"String Indexing and Length","text":"<p>Need to extract the file extension from a filename? Validate that a password meets minimum length? Get the first letter of someone's name for an avatar? All require accessing specific positions in strings or checking their length.</p> <p>Strings are sequences, which means each character has a position (index):</p> String Indexing<pre><code>language = \"Python\"\nprint(language[0])    # (1)!\nprint(language[5])\nprint(language[-1])   # (2)!\nprint(language[-2])\nprint(len(language))  # (3)!\n</code></pre> <ol> <li>Returns <code>'P'</code> - Python uses zero-based indexing so the first character is at index 0</li> <li>Returns <code>'n'</code> - Negative indices count from the end: -1 is last, -2 is second-to-last, etc.</li> <li><code>len()</code> returns the number of characters in the string (6 in this case)</li> </ol>"},{"location":"basics/data_types/strings/#common-string-methods","title":"Common String Methods","text":"<p>User input is messy. Someone types \"JOHN SMITH\" in all caps. Another enters \"alice@email.com\" when you need case-insensitive comparison. You're displaying book titles that need proper capitalization. String methods handle these real-world text processing tasks.</p> <p>Python strings are immutable, but they have many methods that return modified copies:</p>"},{"location":"basics/data_types/strings/#case-manipulation","title":"Case Manipulation","text":"<p>Converting case is essential for data normalization (comparing user input) and formatting output (displaying titles consistently):</p> Changing Case<pre><code>title = \"the lord of the rings\"\nprint(title.upper())       # (1)!\nprint(title.lower())\nprint(title.title())       # (2)!\nprint(title.capitalize())  # (3)!\n</code></pre> <ol> <li>Returns <code>\"THE LORD OF THE RINGS\"</code> - <code>.upper()</code> converts all characters to uppercase</li> <li>Returns <code>\"The Lord Of The Rings\"</code> - <code>.title()</code> capitalizes the first letter of each word</li> <li>Returns <code>\"The lord of the rings\"</code> - <code>.capitalize()</code> capitalizes only the first letter of the string</li> </ol>"},{"location":"basics/data_types/strings/#finding-and-checking","title":"Finding and Checking","text":"<p>Validating email addresses (does it contain <code>@</code>?), searching documents for keywords, checking if filenames start with a prefix, parsing structured text\u2014all require finding or checking for substrings:</p> Searching Strings<pre><code>text = \"Python is powerful and Python is popular\"\nprint(text.find(\"Python\"))      # (1)!\nprint(text.find(\"Ruby\"))        # (2)!\nprint(text.count(\"Python\"))\nprint(text.startswith(\"Python\"))\nprint(text.endswith(\"popular\"))\n</code></pre> <ol> <li>Returns <code>0</code> - <code>.find()</code> returns the index of the first occurrence</li> <li>Returns <code>-1</code> - when substring is not found, <code>.find()</code> returns -1 (a common programming pattern)</li> </ol>"},{"location":"basics/data_types/strings/#splitting-and-joining","title":"Splitting and Joining","text":"<p>CSV files, URLs, command-line arguments, user input with multiple values\u2014all arrive as single strings that need parsing. Split them into pieces for processing, then join the results back together:</p> Split and Join<pre><code>sentence = \"Python is great\"\nwords = sentence.split()        # (1)!\nprint(words)                    # ['Python', 'is', 'great']\n\ncsv_data = \"Alice,30,Engineer\"\nfields = csv_data.split(\",\")    # (2)!\nprint(fields)                   # ['Alice', '30', 'Engineer']\n\n# Join reverses split\nnew_sentence = \" \".join(words)  # (3)!\nprint(new_sentence)             # \"Python is great\"\n</code></pre> <ol> <li><code>.split()</code> with no argument splits on whitespace\u2014returns a list of words</li> <li><code>.split(\",\")</code> splits on commas\u2014useful for CSV data</li> <li><code>\" \".join(list)</code> joins list elements with spaces between them</li> </ol>"},{"location":"basics/data_types/strings/#working-with-whitespace","title":"Working with Whitespace","text":"<p>Users add trailing spaces in form fields. Tab characters appear in TSV files. You need to format output with proper indentation. Whitespace characters (spaces, tabs, newlines) matter in text processing:</p> Whitespace Characters<pre><code>print(\"Hello\\tWorld\")     # (1)!\nprint(\"Line 1\\nLine 2\")   # (2)!\n</code></pre> <ol> <li><code>\\t</code> inserts a tab character (typically displays as 4-8 spaces)</li> <li><code>\\n</code> inserts a newline character, starting a new line</li> </ol> <p>Stripping whitespace is critical when processing user input\u2014\"alice\" and \"alice \" shouldn't be treated as different users:</p> Stripping Whitespace<pre><code>user_input = \"   Alice   \"\nprint(user_input.strip())   # (1)!\nprint(user_input.lstrip())  # (2)!\nprint(user_input.rstrip())  # (3)!\n</code></pre> <ol> <li>Returns <code>\"Alice\"</code> - <code>.strip()</code> removes whitespace from both ends (crucial for cleaning user input)</li> <li>Returns <code>\"Alice   \"</code> - <code>.lstrip()</code> removes whitespace from the left side only</li> <li>Returns <code>\"   Alice\"</code> - <code>.rstrip()</code> removes whitespace from the right side only</li> </ol>"},{"location":"basics/data_types/strings/#multiline-strings-and-raw-strings","title":"Multiline Strings and Raw Strings","text":"<p>SQL queries, HTML templates, help text, formatted messages\u2014readability matters. Triple quotes let you write multiline strings naturally without concatenation or <code>\\n</code> everywhere:</p> Multiline Strings<pre><code>poem = \"\"\"The road goes ever on and on,\nDown from the door where it began.\nNow far ahead the road has gone.\"\"\"  # (1)!\nprint(poem)\n</code></pre> <ol> <li>Triple quotes preserve line breaks exactly as written</li> </ol> <p>Regular expressions use lots of backslashes. Windows file paths use backslashes. Without raw strings, you'd need to double every backslash (<code>\\\\</code>). Raw strings treat backslashes literally, saving you from escaping hell:</p> Raw Strings<pre><code>regex_pattern = r\"\\d{3}-\\d{2}-\\d{4}\"  # (1)!\nwindows_path = r\"C:\\Users\\Alice\\Documents\"  # (2)!\n</code></pre> <ol> <li>The <code>r</code> prefix makes this a raw string\u2014<code>\\d</code> stays as literal <code>\\d</code>, not an escape sequence</li> <li>Without the <code>r</code>, you'd need to double every backslash: <code>\"C:\\\\Users\\\\Alice\\\\Documents\"</code></li> </ol>"},{"location":"basics/data_types/strings/#string-immutability","title":"String Immutability","text":"<p>Why can't you change a string's characters in place? Immutability enables performance optimizations (string interning), makes strings safe as dictionary keys, and prevents bugs in concurrent code. When you \"modify\" a string, you're actually creating a new one:</p> Immutability Demonstration<pre><code>original = \"Alice\"\n\n# Cannot modify in place - would raise TypeError:\n# original[0] = \"B\"\n\n# Must create a NEW string\nmodified = f\"B{original[1:]}\"  # (1)!\nprint(modified)   # (2)!\nprint(original)   # (3)!\n</code></pre> <ol> <li>Create a new string using an f-string with the slice <code>original[1:]</code> (everything after the first character)</li> <li>Prints <code>\"Blice\"</code> - the new string</li> <li>Prints <code>\"Alice\"</code> - the original string remains unchanged, proving immutability</li> </ol> <p>This immutability makes strings safe for use as dictionary keys and enables performance optimizations.</p>"},{"location":"basics/data_types/strings/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Indexing <p>What does <code>\"Python\"[-2]</code> return?</p> Answer <p>It returns <code>'o'</code> (the second-to-last character). Negative indices count backwards from the end: <code>-1</code> is the last character, <code>-2</code> is second-to-last, etc.</p> Practice Problem 2: String Methods <p>Given <code>text = \"  hello world  \"</code>, what's the difference between <code>text.strip().title()</code> and <code>text.title().strip()</code>?</p> Answer <p>They produce the same result: <code>\"Hello World\"</code>. Method chaining processes left-to-right, but in this case the order doesn't matter since <code>.strip()</code> only removes whitespace and <code>.title()</code> only affects capitalization.</p> Practice Problem 3: F-Strings <p>Write an f-string that prints <code>\"The sum of 5 and 3 is 8\"</code> using variables <code>a = 5</code> and <code>b = 3</code>.</p> Answer <pre><code>a = 5\nb = 3\nprint(f\"The sum of {a} and {b} is {a + b}\")\n</code></pre> <p>F-strings evaluate expressions inside <code>{...}</code>, so <code>{a + b}</code> computes the sum.</p> Practice Problem 4: Split and Join <p>How would you convert <code>\"one,two,three\"</code> into <code>\"one-two-three\"</code>?</p> Answer <pre><code>text = \"one,two,three\"\nresult = \"-\".join(text.split(\",\"))\n</code></pre> <p>First <code>.split(\",\")</code> creates <code>['one', 'two', 'three']</code>, then <code>\"-\".join(...)</code> combines them with hyphens.</p>"},{"location":"basics/data_types/strings/#key-takeaways","title":"Key Takeaways","text":"Concept What It Means String Immutable sequence of Unicode characters Indexing Access characters by position (zero-based, negative from end) F-strings Modern way to embed values: <code>f\"Hello, {name}!\"</code> Immutability Strings cannot be changed\u2014methods return new strings Methods <code>.upper()</code>, <code>.lower()</code>, <code>.strip()</code>, <code>.split()</code>, <code>.find()</code>, etc. Raw strings <code>r\"...\"</code> treats backslashes literally"},{"location":"basics/data_types/strings/#further-reading","title":"Further Reading","text":"<ul> <li>Python String Documentation - Official reference for all string methods</li> <li>PEP 498 \u2013 Literal String Interpolation - The proposal that introduced f-strings</li> <li>Unicode HOWTO - Deep dive into Unicode support in Python</li> <li>Python String Formatting Best Practices - Real Python guide to f-strings</li> <li>Regular Expressions - Advanced pattern matching for complex string operations</li> <li>How Parsers Work - Understanding how text gets parsed and processed</li> </ul> <p>Strings are the foundation of text processing in Python. Master them early, and countless tasks\u2014from parsing CSV files to building web applications\u2014become straightforward. The methods are intuitive, f-strings are elegant, and the immutability prevents subtle bugs.</p> <p>Every expert Python programmer started here, learning to slice, format, and manipulate text. Now it's your turn.</p>"},{"location":"intermediate/iterators_and_generators/","title":"Iterators and Generators","text":"<p>Iterators and generators are important memory-saving tools in Python. They allow you to work with sequences of data (of any size) without loading everything into memory at once. Instead, each member of the iterable is processed individually. This is especially useful when dealing with large datasets or streams of data.</p>"},{"location":"intermediate/iterators_and_generators/#what-is-an-iterable","title":"What is an Iterable?","text":"<p>An iterable is any Python object that can return its members one at a time, allowing it to be iterated over using a loop (see For Loops and While Loops). The order in which iterables are iterated over depends on their type. For example:</p> <ul> <li>Sequentially: Lists,     Tuples, and     Strings.</li> <li>Insertion Order: Dictionaries.</li> <li>Unordered: Sets.</li> </ul> Tip <p>Not everything in Python is iterable. For example, integers and floats are not iterable. If you try to iterate over them, you'll get a <code>TypeError</code> exception.</p> <p>You can check if an object is iterable by using the <code>isinstance()</code> function with the <code>collections.abc.Iterable</code> class.</p> Checking if Iterable<pre><code>from collections.abc import Iterable\ndef is_iterable(obj):\n    return isinstance(obj, Iterable)\n\nprint(is_iterable([1, 2, 3]))\nprint(is_iterable(\"Hello\"))\nprint(is_iterable(42)) # (1)\n</code></pre> <ol> <li>Integers are not iterable, so this will return <code>False</code>.</li> </ol> <p>Would return:</p> <pre><code>True\nTrue\nFalse\n</code></pre>"},{"location":"intermediate/iterators_and_generators/#what-is-an-iterator","title":"What is an Iterator?","text":"<p>An iterator is any object that implements the iterator protocol, which consists of two methods:</p> <ul> <li><code>__iter__()</code>: Returns the iterator object itself.</li> <li><code>__next__()</code>: Returns the next value from the iterator. If there are no more     items, it raises a <code>StopIteration</code> exception.</li> </ul>"}]}